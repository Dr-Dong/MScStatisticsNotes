\documentclass[12pt]{article}
%\usepackage[landscape]{geometry}  
\usepackage[landscape,hmargin=2cm,vmargin=1.5cm,headsep=0cm]{geometry} 
% See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{multicol}

\usepackage{graphicx}

 \usepackage{float}
 \setkeys{Gin}{width=0.25\textwidth}

\usepackage[table]{xcolor}

\newcommand\x{\times}
\newcommand\y{\cellcolor{green!10}}

\newcommand{\pder}[2][]{\frac{\partial#1}{\partial#2}}

\newcommand{\argmin}{\arg\!\min}
\newcommand{\argmax}{\arg\!\max}


\newtheorem{definition}{Definition}

\newtheorem{theorem}{Theorem}

\newtheorem{fact}{Fact}

\newtheorem{proposition}{Proposition}


% Turn off header and footer
\pagestyle{plain}
 

% Redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\small\bfseries}}
\makeatother

% Define BibTeX command
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Don't print section numbers
%\setcounter{secnumdepth}{0}

\newcommand{\eps}{\epsilon}
\newcommand{\al}{\alpha}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}


\usepackage{Sweave}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\usepackage{cancel}

%% taken from http://brunoj.wordpress.com/2009/10/08/latex-the-framed-minipage/
\newsavebox{\fmbox}
\newenvironment{fmpage}[1]
{\begin{lrbox}{\fmbox}\begin{minipage}{#1}}
{\end{minipage}\end{lrbox}\fbox{\usebox{\fmbox}}}

\usepackage{mathtools}
\makeatletter
 
\newcommand{\explain}[2]{\underset{\mathclap{\overset{\uparrow}{#2}}}{#1}}
\newcommand{\explainup}[2]{\overset{\mathclap{\underset{\downarrow}{#2}}}{#1}}
 
\makeatother

\SweaveOpts{prefix.string=MatAlgfigs/MatAlgfig}

\SweaveOpts{cache=TRUE}

\title{Multivariate Analysis Summary Sheet}
\author{Shravan Vasishth (vasishth@uni-potsdam.de)}
\date{\today}                                           % Activate to display a given date or no date

\newcommand\myfigure[1]{%
\medskip\noindent\begin{minipage}{\columnwidth}
\centering%
#1%
%figure,caption, and label go here
\end{minipage}\medskip}


\begin{document}

\SweaveOpts{concordance=TRUE}
\footnotesize
\maketitle
\tableofcontents

\newpage

\begin{multicols}{3}


% multicol parameters
% These lengths are set only within the two main columns
%\setlength{\columnseprule}{0.25pt}
\setlength{\premulticols}{1pt}
\setlength{\postmulticols}{1pt}
\setlength{\multicolsep}{1pt}
\setlength{\columnsep}{2pt}

\begin{center}
     \normalsize{Multivariate Analysis Summary Sheet} \\
    \footnotesize{
    Compiled by: Shravan Vasishth (vasishth@uni-potsdam.de)\\
    Version dated: \today}
\end{center}

<<echo=F>>=
options(width=60)
options(continue=" ")
@

\section{Preliminaries}

We will treat $X'$ as the data matrix:

\begin{equation}
X'=\begin{pmatrix}
x_{11} & \dots & x_{1p}\\
\vdots & \vdots & \vdots \\
x_{n1} & \dots & x_{np}\\
\end{pmatrix}
\end{equation}

\subsection{Sample mean}

The \textbf{sample mean vector} is:

\begin{equation}
\bar{x} = \begin{pmatrix}
\bar{x}_1 \\
\vdots\\
\bar{x}_p\\
\end{pmatrix}
=
\frac{1}{n} 
\begin{pmatrix}
x_{11} + \dots + x_{n1}\\
\vdots  \\
x_{1p} + \dots + x_{np}\\
\end{pmatrix}
\end{equation}

More compactly: $\bar{x} = \frac{1}{n}X1 \Leftrightarrow \bar{x}' = \frac{1}{n}1'X'$.

\subsection{Sample variance}

Sample variance (variance-covariance) matrix:

\begin{equation}
S_{p\times p} = var(X') = \frac{1}{n-1} (X-\bar{X}) (X-\bar{X})'
\end{equation}

$\bar{X}_{p\times n}=[\bar{x} \dots \bar{x}]$

\textbf{Properties of S}:

$S$ is symmetric, $S_{ii}$ is sample variance, and $S_{ij}$ is sample covariance.

If columns of S are linearly independent (i.e., if none of the variables is a linear combination of the other), S is non-singular, and positive definite.

The \textbf{sample correlation matrix} R is the same as the vcov matrix, but has entries scaled:

\begin{equation}
r_{ij}=\frac{s_{ij}}{\sqrt{s_{ii}s_{jj}}}
\end{equation}

If $L$ be the diagonal matrix:

$
\begin{pmatrix}
s_{11} & \dots & 0\\
0 & \dots & 0\\
0 & \dots & s_{nn}\\
\end{pmatrix}
$
and $L^{1/2}$ has sds along the diagonal, then

\begin{equation}
S=L^{1/2} R L^{1/2}
\end{equation}

\begin{enumerate}
\item R is symmetric, $p\times p$
\item $r_{ii}=1$ for all i
\item $-1 \leq r_{ij} 1$.
\item Geometrically, $r_ij$ is the cosine of the angle between the vectors of deviations of observations of the ith and jth variables from the mean.
\begin{enumerate}
\item If angle is 0 deg (0 rad), $\rho=1$.
\item If angle is 90 deg ($\pi/2$ rad), $\rho=0$.
\end{enumerate}
to-do example
\end{enumerate}

\section{Some useful results}

\begin{enumerate}
\item
Let $w$ be a vector. Then $var(X'w) = w'var(X')w=w'Sw$. 
\item If $A$ is any $p\times q$ matrix, then $Var(X'A)=A'Var(X')A=A'SA$.
\end{enumerate}

\section{Useful properties of eigenvalues and eigenvectors}

Let $A_{p\times p}$, and let eigenvalues be $\lambda_i$.

\begin{enumerate}
\item $\sum \lambda_i = trace(A)$
\item $\prod \lambda_i = det(A)$
\item If $\lambda_i$ is an eigenvalue of A, then there is at least one vector $x_i$, called an eigenvector of A, such that $Ax_i = \lambda_i x_i$.
\item If A is realand symmetric $p\times p$, then there are always p linearly independent eigenvectors.
\item If C is any non-singular square matrix, then A and $CAC^{-1}$ have the same eigenvalues. If $x_i$ is an eigenvector of A with eigenvalue $\lambda_i$, then $Cx_i$ is an  eigenvector of $CAC^{-1}$ with eigenvalue $\lambda_i$. [Prove it]
\item If A is real symmetric, i.e., $A=A'$. Then the eigenvalues of A are real. [Prove it]
\item If A is real symmetric, and $\lambda$ and $\mu$ are eigenvalues, and x and y are corresponding eigenvectors, then x and y are orthogonal. [Prove it]
\item If A is real symmetric, and if X denotes the matrix whose columns are normalized eigenvectors of A, then X is an orthogonal matrix ($XX'=I$, or $X'=X^{-1}$). [Prove it]

Also, $X^{-1}AX=\Lambda$, where $\Lambda$ is the diagonal matrix containing the eigenvalues of A along the diagonal. This is because $AX = X\Lambda$.

The decomposition $X^{-1}AX=\Lambda$ is called the \textbf{spectral decomposition}, and is equivalent to 

\begin{equation}
A=\lambda_1 x_1 x_1' + \dots + \lambda_p x_p x_p'
\end{equation}

where $x_i$ is an eigenvector of A with eigenvalue $\lambda_i$.
\item 
If A is any positive definite real symmetric matrix, it will have positive definite real symmetric square roots. [Prove it]
%If A is any positive definite real symmetric matrix, with orthogonal eigenvectors $x_1,\dots,x_p$, corresponding to eigenvalues $\lambda_1,\dots,\lambda_p$ (which are positive). 
\item The eigenvalues of a variance-covariance matrix are non-negative.
\end{enumerate}

\section{Vector calculus review}

Some useful results:

\begin{enumerate}
\item 
If S is a symmetric $p\times p$ vector, and if $f(x)=x'Sx$. Then $\frac{\delta f}{\delta x} = 2Sx$. [Derive this.]
\item 
If S is not symmetric, $\frac{\delta f(x)}{\delta x} = (S + S')x$
\item
If S is I, then $\frac{\delta f(x)}{\delta x}=\frac{\delta x'x}{\delta x}=2x$.
\item If a is a constant p-vector, and $f(x)=a'x$, then $\frac{\delta f}{\delta x}=a$. 
\end{enumerate}

\section{Constrained optimization (Lagrange Multipliers)}

Suppose $t_1, \dots, t_n$ are unbiased estimates of $\theta$, and variance of $t_i$, $i=1,\dots,n$, is $\sigma_i^2$.

<<>>=
## t_i, equal variance
t<-rnorm(10)
@

Find \textbf{B}est \textbf{L}inear \textbf{U}nbiased \textbf{E}stimator of $\theta$.

Solution:

The BLUE of $\theta$ will be a weighted sum of the $t_i$. Let this weighted sum be $\tau = \sum a_i t_i$, such that $E[\tau]=\theta$. 

We need to minimize the variance: $Var(\tau)=Var(\sum a_i t_i)=\sum a_i^2 Var(t_i)=\sum a_i^2\sigma_i^2$.

Since $E[t_i] = E[\tau]=\theta$, the weights $a_i$ must sum to 1. So the constraint is that $\sum a_i = 1$. 

So, we minimize this function:

\begin{equation}
\Omega = \sum a_i^2\sigma_i^2 + \lambda (\sum a_i - 1)
\end{equation}

Differentiating with respect to  each $a_i$, we get: $2 a_i\sigma_i^2 +\lambda = 0$, which implies that

\begin{equation}\label{ai}
a_i = -\frac{\lambda}{2 \sigma_i^2}
=
-\frac{1}{2}\frac{\lambda}{\sigma_i^2}
\end{equation}

Differentiating with respect to the Lagrangian, we get

\begin{equation}
\sum a_i - 1 = 0
\end{equation}

Replacing $a_i$ in the above with the RHS in equation~\ref{ai},

\begin{equation}
\sum  -\frac{1}{2}\frac{\lambda}{\sigma_i^2} - 1 = 0
\end{equation}

Adding -1 to both sides:

\begin{equation}
\sum  -\frac{1}{2}\frac{\lambda}{\sigma_i^2}  = 1
\end{equation}

Multiplying both sides by -1:

\begin{equation}
\sum  \frac{1}{2}\frac{\lambda}{\sigma_i^2}  = -1
\end{equation}

Solve for $\lambda$ (change index i to k):

\begin{equation}
\lambda   = \frac{-1}{\frac{1}{2}}\frac{1}{\frac{1}{\sum \sigma_k^2}} = \frac{-2}{\frac{1}{\sum \sigma_k^2}}
\end{equation}

Now we can figure out each $a_i$ by plugging in $\lambda$ into 

\begin{equation}
a_i = -\frac{1}{2}\frac{\lambda}{\sigma_i^2} = -\frac{1}{2}\frac{\frac{-2}{\frac{1}{\sum \sigma_k^2}}}{\sigma_i^2} = \frac{1}{\sigma_i^2} \left[ \frac{1}{\sum \sigma_k^2}\right]^{-1}
\end{equation}

Finally, we need to plug in the definition of $a_i$ into $\tau=\sum a_i t_i$. At this stage it makes sense to use the index i again (instead of k):

\begin{equation}
\tau = \sum a_i t_i = \sum \left[ 
\frac{1}{\sigma_i^2} \left[ \frac{1}{\sum \sigma_k^2}\right]^{-1}
\right] t_i = \sum \frac{t_i}{\sigma_i^2} \left[ \frac{1}{\sum \sigma_k^2}\right]^{-1}
\end{equation}

\section{Multivariate distributions}

Definition: If $\mu$ is a p-vector and $\Sigma$ is a positive definite symmetric $p\times p$ matrix, then MVN distribution $N_p(\mu,\Sigma)$ is:

\begin{equation}
f_x(x) = \frac{1}{(2\pi)^{p/2} \mid \Sigma \mid^{1/2} } \exp \left( -\frac{1}{2} (x-\mu)' \Sigma^{-1} (x-\mu) \right)
\end{equation}

\begin{enumerate}
\item
The quadratic form $(x-\mu)' \Sigma^{-1} (x-\mu)$ in the kernel is a statistical distance measure; for any value of x, the quadratic form gives the squared statistical distance of x from $\mu$, called squared Mahalanobis distance.  
\item
Note that the MVN density is constant on surfaces of contours where

$(x-\mu)' \Sigma^{-1} (x-\mu)=c^2$

``The axes of each ellipsoid of constant density are in the direction of the eigen- vectors of $\Sigma^-1$ (recall that these are the same as the eigenvectors of $\Sigma$, but if $\Sigma x=\lambda x$, then
$\Sigma^{-1} x=\lambda^{-1} x$), and their lengths are proportional to the reciprocals of the square roots of the eigenvalues of $\Sigma^{-1}$.'' (p.\ 95)

\item 
If $x \sim N_p(\mu,\Sigma)$,
then

\begin{enumerate}
\item
$(x-\mu)' \Sigma^{-1} (x-\mu)\sim \chi_p^2$.
\item 
The solid ellipsoid $\{x\mid (x-\mu)' \Sigma^{-1} (x-\mu) \leq \chi_p^2(\alpha)\}$ has probability $1-\alpha$.
\end{enumerate}

This follows from the fact that if $x\sim N_p(\mu,\Sigma)$ then 
$y=\Sigma^{1/2} (x-\mu)\sim N_p(0,I_p)$ and therefore:

\begin{equation}
y'y = (x-\mu)' \Sigma^{-1} (x-\mu) = \sum_{i=1}^2 Y_i^2 \sim \chi_p^2
\end{equation}

``One of the consequences of the properties is that the marginal distributions of the individual variables of a multivariate normal distribution is a univariate normal distribu- tion.'' (p.\ 96)

\item
If $X\sim N_p(\mu,\Sigma)$ and w is a p-vector, then the linear combination $w'X \sim N(w'\mu,w'\Sigma w)$.
\item 
If $X\sim N_p(\mu,\Sigma)$ and A is a $q\times p$ matrix, then the linear combination $AX \sim N(A\mu,A\Sigma A')$.
\item 
If $X\sim N_p(\mu_X,\Sigma_X)$ and $Y\sim N_q(\mu_Y,\Sigma_Y)$, then the p+q vector 

$\begin{pmatrix}
X\\
Y
\end{pmatrix}
\sim N_{p+q}\left( 
\begin{pmatrix}
\mu_X\\
\mu_Y
\end{pmatrix},
\begin{pmatrix}
\Sigma_X & 0 \\
0 & \Sigma_Y\\
\end{pmatrix}
\right)
$

as long as X and Y are independent.
\item 
If
$\begin{pmatrix}
X\\
Y
\end{pmatrix}
\sim N_{p+q}\left( 
\begin{pmatrix}
\mu_X\\
\mu_Y
\end{pmatrix},
\begin{pmatrix}
\Sigma_X & \Sigma \\
\Sigma' & \Sigma_Y\\
\end{pmatrix}
\right)
$

then X and Y are independent iff $\Sigma=0$.

\end{enumerate}

\section{Principal Components Analysis}

Useful mostly when we have continuous data.

[Sources: Tutorial on PCA by Shlens, ]

Let $X_{n\times p}$ be our data, where we have p different variables, and n measurements on each variables. Example:

<<>>=
n<-5
x1<-c(1,3,5,7,9)
x2<-c(4,7,8,11,15)
## n=5, p=2:
X<-data.frame(x1=x1,x2=x2)
## centered variables:
x1<-scale(x1,scale=F)
x2<-scale(x2,scale=F)
X<-data.frame(x1,x2)
X<-as.matrix(X)
@

The matrix $\frac{1}{n-1}X'X$ is the real symmetric variance-covariance matrix, and represents the relationships between the variables:

<<print=TRUE>>=
var1<-(1/(n-1))*t(X)%*%X
var2<-var(X)
@

The total amount of dispersion on the data is the sum of the variances (the trace):

<<>>=
## sum of the variances=the total dispersion:
sum(diag(var2))
@

\begin{fact}
Any symmetric matrix X is 
diagonalized by an orthogonal matrix of its eigenvectors (see Theorems 1 and 2 in MatrixAlgebraSummary.pdf). 
For a symmetric matrix X, $X = EDE^T$, 
where D is a diagonal matrix and E is a matrix of eigenvectors of X arranged as columns.
\end{fact}


\textbf{PCA using eigenvalue decomposition}:

The goal is to find some orthonormal matrix P in $Y = PX$ such that the covariance matrix $C_Y = \frac{1}{n} Y Y^T$ is a diagonal matrix. The rows of P are the \textit{principal components} of X.

First, write $C_Y$ in terms of the unknown Y:

\begin{equation}
\begin{split}
C_Y =& \frac{1}{n} Y Y^T\\
    =& \frac{1}{n} (PX)(PX)^T\\
    =& \frac{1}{n} PXX^T P^T\\
    =& P (\frac{1}{n} XX^T) P^T\\
C_Y =& PC_X P^T \\   
\end{split}
\end{equation}

Choose P to be a matrix such that each row $p_i$ is an eigenvector of $Cov_X$. So $P=E^T$ where E has the eigenvectors of X in each column. Also note that $P^{-1} = P^T$.

Next, we show that this choice of P diagonalizes $C_Y$---that's the goal of PCA.
\begin{equation}
\begin{split}
C_Y =& PC_X P^T\\
    =& P(E^TDE)P^T\\
    =& P(P^TDP)P^T\\
    =& (PP^T) D (PP^T)\\
    =& (PP^{-1}) D (PP^{-1})\\
C_Y    =& D
\end{split}
\end{equation}

Key point: the i-th diagonal value $C_Y$ is the variance of X along the principal component (an eigenvector) $p_i$.

The real symmetric var-cov matrix var2 can be decomposed into $U\lambda U'$, where

\begin{enumerate}
\item
U is the orthonormal matrix containing the eigenvectors of var2
\item 
$\lambda$ is a diagonal matrix containing the eigenvalues of var2
\end{enumerate}

<<>>=
lambda<-diag(eigen(var2)$values)
U<-eigen(var2)$vectors
U%*%lambda%*%t(U)
@

We want to linearly transform the vectors 
x1 and x2:

\begin{center}
\includegraphics[height=5cm,width=7cm]{bestfitPC}
\end{center}

In this figure, the largest direction of variance lies along the best fit line, not perpendicular to the best fit line. Thus, by assumption, the dynamics of interest lie along the direction with largest variance. Maximizing the variance corresponds to finding the appropriate rotation of the naive basis.

\textbf{By transforming $X'$ to $Y'=aX'$, we have projected $X'$ onto $a$, a one-dimensional space, a single line. The values of $Y'$ give the co-ordinates of each observation along the vector a}.

For example, if we have 
$x_1 = 
\begin{pmatrix}
1\\
2
\end{pmatrix}, 
x_2 = 
\begin{pmatrix}
2\\
1
\end{pmatrix}, 
x_3 = 
\begin{pmatrix}
-1\\
1
\end{pmatrix}$, and 
$a = 
\begin{pmatrix}
\frac{3}{5}\\
\frac{-4}{5}
\end{pmatrix}$, then 

$X' = 
\begin{pmatrix}
1 & 2\\
2 & 1\\
-1 & 1 
\end{pmatrix}$. 

Therefore $Y' = X'a = 
\begin{pmatrix}
-1 \\
\frac{2}{5}\\
-\frac{7}{5}
\end{pmatrix}$.

So, $x_1 = -1.a + z_1$ where $z_1$ is orthogonal to a. And so on.

<<echo=FALSE>>=
op<-par(mfrow=c(1,2),pty="s")
plot(x1,x2,xlim=c(-6,6),ylim=c(-6,6),
     main="")
abline(lm(x2~x1))
## First PC is always along the line
## of best fit:
arrows(x0=0,y0=0,x1=5*U[1,1],y1=5*U[2,1],lwd=2)
arrows(x0=0,y0=0,x1=5*U[1,2],y1=5*U[2,2],lty=2)
#legend(x=-5,y=20,lty=c(1,2),legend=c("PC1","PC2"))
library(MVA)
bvbox(X)
arrows(x0=0,y0=0,x1=5*U[1,1],y1=5*U[2,1],lwd=2)
arrows(x0=0,y0=0,x1=5*U[1,2],y1=5*U[2,2],lty=2)
@

If the maximum variance were \textit{not}
along the line of best fit, but in a perpendicular direction, the first PC would point in that direction:

<<echo=FALSE>>=
x1<-c(1,2,3,3,2)
x2<-c(20,55,4,30,5)
x1<-scale(x1,scale=F)
x2<-scale(x2,scale=F)
op<-par(mfrow=c(1,2),pty="s")
plot(x1,x2,xlim=c(-33,33),ylim=c(-33,33))
abline(lm(x2~x1))
X<-data.frame(x1,x2)
X<-as.matrix(X)
lambda<-eigen(var(X))$values
U<-eigen(var(X))$vectors
arrows(x0=0,y0=0,x1=20*U[1,1],y1=20*U[2,1])
arrows(x0=0,y0=0,x1=20*U[1,2],y1=20*U[2,2],lty=2)

bvbox(X)
arrows(x0=0,y0=0,x1=5*U[1,1],y1=20*U[2,1],lwd=2)
arrows(x0=0,y0=0,x1=U[1,2],y1=U[2,2],lty=2)
@
\begin{center}
\includegraphics[height=5cm,width=7cm]{PC2}
\end{center}


Assumption (sometimes incorrect): \textbf{Large variances have important structure}. 
Therefore maximize variance to find the most important PCs.

The reasoning is that if variance is small, then all the observations have similar values, so there is little information in the data. If variance is large, then we have more ``information''.

\subsection{Geometric interpretation}

Basically, the PCA method just rotates the data so that the ellipsoid's axes are the principal components.

\subsection{Presentation from lecture notes}

\textbf{Goal}: reduce $X_{n\times p}$ to $Y_{n\times q}$

``A linear transformation $X' \rightarrow Y'$ is given by $Y'=X'A$ where A is a $p\times p$-matrix; it makes statistical sense to restrict attention to non-singular matrices A. If A happens to be an orthogonal matrix, i.e., $A'A=I_p$,then the transformation $X'\rightarrow Y'$  is an orthogonal transformation (i.e., just a rotation and/or a reflection of the n points in p-dimensional space)''.

We want to choose A such that variance X'A is maximized; this is because ``maximizing the variance corresponds to finding the appropriate rotation of the naive basis'' (Shlens tutorial). 

How to choose A such that variance of $X'A$ is maximized? If we just choose some A:
<<>>=
m<-matrix(rnorm(1000),byrow=TRUE,ncol=10)
diag(var(m))
a<-matrix(rnorm(100),byrow=TRUE,ncol=10)
@
You can increase variance arbitrarily
by multiplying a with some number, here 2:

<<>>=
head(round(diag(m1<-var(m%*%a)),digits=2))
head(round(diag(m2<-var(m%*%(2*a))),
           digits=2))
@
Notice that variances have increased by
a factor of $2^2$:

<<>>=
diag(m2)/diag(m1)
@

\textbf{The point here}: The ``maximum variance'' here is unbounded. We can increase it arbitrarily. To maximize variance, we have to constrain it somehow, and that's why a constraint is imposed (below), that $w_i' w_i$ sums to 1 and the eigenvectors $w_i, w_j$ ($i\neq j$) are orthogonal.

\begin{theorem}
The $p$ principal components of data $X'$ are the $p$ eigenvectors $a_1,\dots,a_p$ corresponding to the $p$ ordered eigenvalues $\lambda_1 \geq \dots \geq \lambda_p$ of S, the variance of $X'$.
[Theorem 3.3 in lecture notes]
\end{theorem}

\begin{definition}
The first principal component is the vector $a_1$ such that the projection of the data $X'$ onto $a_1$, i.e., $X'a_1$, has maximal variance, subject to the normalising constraint that $a_1'a_1 = 1$ (i.e., $a_1$ has length 1).
\end{definition}

\subsection{PCA example by hand}

To find first PC, we maximize $w_1 S w_1$ subject to $w_1' w_1=1$, where $S=X'X$. $w_1$ will be the eigenvector representing the direction of the maximum variance.

\begin{equation}
w_1' S w_1 - \lambda_1 (w_1' w_1 -1)
\end{equation}

Differentiating with respect to $w_1$ gives:

\begin{equation}
S w_1 - \lambda_1 w_1 = 0 \Leftrightarrow 
S w_1 = \lambda_1 w_1
\end{equation}

But this means that $\lambda_1$ is an eigenvalue of S, and that $w_1$ is the corresponding eigenvector.

When finding the second principal component, we want to ensure that $w_2$ is uncorrelated to $w_1$. This means that $w_2' S w_1=0$, but since $S w_1 = \lambda_1w_1$, we have $w_2' w_1 = 0$.

So the second PC $w_2$ should have the property that the projection of $X'$ onto $w_2$ should have maximum variance subject to $w_2'w_2=1$ and 
$w_2' w_1 = 0$. Since we have two constraints we will use two Lagrangian multipliers:

\begin{equation}
\Omega_2 = w_2' S w_2 -\mu w_2' w_1 - \lambda_2(w_2' w_2 -1 )
\end{equation}

Differentiate with respect to $w_2$:

\begin{equation} \label{e0}
2S w_2 -\mu w_1 - 2\lambda_2 w_2=0
\end{equation}

Pre-multiplying each side with $w_1'$:

\begin{equation}\label{e1}
2w_1'S w_2 -\mu w_1'w_1 - 2\lambda_2 w_1'w_2=0
\end{equation}

Pre-multiplying by $w_2'$:

\begin{equation}\label{e3}
2w_2'S w_2 -\mu w_2'w_1 - 2\lambda_2 w_2'w_2=0
\end{equation}

Because $\lambda_2 w_1'w_2=0$, we can see from equation~\ref{e1} that

\begin{equation}
\mu = 2w_1'S w_2 = 2(Sw_a)' w_2 = 2(\lambda_1 w_1)' w_2 = 2\lambda_2 w_1' w_2=0
\end{equation}

From equation~\ref{e0}, we can then conclude that

\begin{equation}
2S w_2 = \lambda_2 w_2
\end{equation}

Therefore, $w_2$ is an eigenvector of S, with eigenvalue $\lambda_2$.

Recall that $var(X'w_2) = w_2'var(X')w_2 = w_2'Sw_2$. Equation~\ref{e3} is that:

\begin{equation}
2w_2'S w_2 -\mu w_2'w_1 - \lambda_2 w_2'w_2=0
\end{equation}

Replacing $w_2'S w_2$ with $var(X'w_2)$, we get that:

\begin{equation}
2var(X'w_2) -\explain{\mu w_2'w_1}{=0} - 2\lambda_2 w_2'w_2=
var(X'w_2) - 2\lambda_2 = 0
\end{equation}

Therefore, $var(X'w_2) = 2\lambda_2$. This entails that $\lambda_2$ must be the second largest eigenvalue with eigenvector $w_2$. (Question: why is this entailed?)

All Principal Components can be found using the diagonalization of S. The eigenvalue decomposition of S is also called the \textbf{spectral decomposition} of S. The set of eigenvalues is called the \textbf{spectrum} of S.

\subsection{Computing PCs using eigen()}

<<>>=
x<-c(1,3,5,7,9)
y<-c(4,7,8,11,15)
plot(x,y)
xy<-data.frame(x=x,y=y)
var_matrix<-var(xy)
lambda<-eigen(var_matrix)$values
eigenvectors<-eigen(var_matrix)$vectors
## first principal component 
## contains 99.2% of 
## the information:
lambda[1]/(lambda[1]+lambda[2])
## using prebuilt function:
xy_pc<-princomp(xy)
plot(xy_pc)
#source("code/scree.R")
@

\subsection{How to map the points onto the PC}

Take the first example above:

<<>>=
n<-5
x1<-c(1,3,5,7,9)
x2<-c(4,7,8,11,15)
## n=5, p=2:
## centered variables:
x1<-scale(x1,scale=F)
x2<-scale(x2,scale=F)
X<-data.frame(x1,x2)
X<-as.matrix(X)
S<-var(X)
lambda<-eigen(S)$values
U<-eigen(S)$vectors
@

The first set of points $x_1=(1,4)$, and $e_1$ is the first PC.

\begin{equation}
x_1  = \bar{x} + te_1 + ue_2
\end{equation}

$\bar{x}=0$ as data are centered, so we have:

\begin{equation}
x_1  = te_1 + ue_2
\end{equation}
 Premultiplying by $e_1$:
 
\begin{equation}
e_1' x_1  = e_1' te_1 + e_1' ue_2 = t
\end{equation}

So, $t= e_1' x_1$ (\textbf{or}: $t= x_1' e_1$), so $x_1=t e_1$. I.e.,
$t e_1$ is the point where 
$x_1$ is mapped on to on the first PC. 

<<echo=FALSE>>=
x1<-c(1,3,5,7,9)
x2<-c(4,7,8,11,15)
## n=5, p=2:
X<-data.frame(x1=x1,x2=x2)
## centered variables:
x1<-scale(x1,scale=F)
x2<-scale(x2,scale=F)
X<-data.frame(x1,x2)

X<-as.matrix(X)
S<-var(X)
lambda<-eigen(S)$values
U<-eigen(S)$vectors
@

<<echo=FALSE>>=
plot(x1,x2,xlim=c(-6,6),ylim=c(-6,6),
     main="")
abline(lm(x2~x1))
## First PC is always along the line
## of best fit:
arrows(x0=0,y0=0,x1=5*U[1,1],y1=5*U[2,1],lwd=2)
arrows(x0=0,y0=0,x1=5*U[1,2],y1=5*U[2,2],lty=2)
arrows(x0=0,y0=0,x1=x1[1],y1=x2[1],lty=1,lwd=2)
t<-t(U[,1])%*%X[1,]
U1<-t*U[,1]
arrows(x0=0,y0=0,x1=U1[1],y1=U1[2],lty=1,lwd=3)
@

\includegraphics[height=5cm,width=7cm]{PCmapping}

\subsection{Computing PCs using the correlation matrix}

Needed when data are of mixed type, or one variable has very high variance compared to others. 

\textbf{Rule of thumb}:
``If the largest variance is more than about 4 times the smallest, then use the correlation matrix (otherwise the variables with large variance will dominate the principal component calculation).''

One should use the vcov matrix if
the scales of measurement are similar,  and the standard deviations of all variables are similar.

\textbf{Note}: The sort of interpretation given in the turtle example is valid only really when the variance matrix is used rather than the correlation matrix.

Interpretation of loadings is only viable for small numbers of variables.


Steps:

\begin{enumerate}
\item Center and scale data to get a correlation matrix:

<<>>=
x1<-c(1,2,4,4,5,6,8,10)
x2<-c(2,3,6,7,8,11,13,14)
x1<-scale(x1,scale=F)
x2<-scale(x2,scale=F)
X<-data.frame(x1,x2)
X<-as.matrix(X)
S<-var(X)
lambda<-eigen(S)$values
U<-eigen(S)$vectors
S_corr<-cov2cor(S)
@

\end{enumerate}

\subsection{Quadratic PCA}

With a very small number of variables, one might try to generalise to e.g., quadratic principal components by adding variables for each quadratic combination.

\subsection{Other things to look up}

\begin{enumerate}
\item Projection pursuit
\item ICA
\item Factor analysis
\item Kohonen's SOMs
\item Generative topographic mapping
\end{enumerate}

\section{Multidimensional scaling}

Goal: visualize a proximity matrix, if possible with a  good lower-dimensional approximation (similar to PCA).

\textbf{The mathematical problem}: $n\times n$ proximity matrix (a symmetric matrix of $\delta_{ij}$ dissimilarities), find a q-dimensional space such that the calculated distance matrix $d_{ij}$ reasonably matches the given dissimilarity matrix $\delta_{ij}$. We can generally find one for $q=n-1$. The more interesting case is when q is very small.

Aims of MDS:

\begin{enumerate}
\item To learn about the measure of dissimilarity itself
\item To discover underlying structure in the data
\item
To see whether the data naturally divides into groups (clustering)
\end{enumerate}


\subsection{Principal coordinate analysis (classical metric scaling)}

PCA = classical MDS

\begin{theorem}
D is a matrix of Euclidean distances iff B is  positive semidefinite (iff all eigenvalues of B are semidefinite).\hfill
[Theorem 4.2, p.\ 52]
\end{theorem}

Given a distance matrix $D=(\delta_{ij})$, we find the configuration of points:

\begin{enumerate}
\item 
Find B=HAH, where $A=-\frac{1}{2} \delta_{ij}^2$, and $H=I_n - \frac{1}{n} J_n$.
\item Find eigenanalysis of B.
\item Transpose matrix of eigenvectors.
\item The columns of this transposed matrix are the principal coordinates of the points.
\end{enumerate}

\textbf{Example}:

<<>>=
x<-c(1,3,5,7,9)
y<-c(4,7,8,11,15)
D<-matrix(rep(NA,25),ncol=5)
## compute Eudlidean distance:
for(i in 1:5){
  for(j in 1:5){
    d<-(x[i]-x[j])^2+(y[i]-y[j])^2
    D[i,j]<-d
  }
}
A<- -0.5 * D
H<-diag(5) - (1/5)*matrix(rep(1,25),ncol=5)

B<- H%*% A %*% H
eigen_B<-eigen(B)
head(eigen_B$values)
## take first eigenvector:
v1<-eigen_B$vectors[,1]
f<-v1*sqrt(eigen_B$values[1])
## D2 fits with D:
D2<-matrix(rep(NA,25),ncol=5)
for(i in 1:5){
  for(j in 1:5){
    d<-(f[i]-f[j])^2
    D2[i,j]<-d
  }
}
@

\section{Cluster analysis}

%http://stackoverflow.com/questions/15376075/cluster-analysis-in-r-determine-the-optimal-number-of-clusters?imm_mid=0bf394&cmp=em-strata-na-na-newsltr_20140702_elist

\section{Multivariate analysis}

To test the null hypothesis: $H_0: \mu_1=\mu_2$.
From the lecture notes (p.\ 102): obtain the sample Mahalanobis distance $D^2$ and reject $H_0$ if 

\begin{equation}
\frac{n_1 n_2 (n-p -1 )}{n(n-2)p} D^2 > F_{p,n-p-1}(\alpha)
\end{equation}

where $D^2$:

\begin{equation}
D^2= (\bar{x}_1-\bar{x}_2)' S^{-1}(\bar{x}_1-\bar{x}_2)
\quad S = \frac{(n_1 -1)S_1 + (n_2 -1)S_2}{n-2}
\end{equation}

To test the hypothesis

\begin{equation}
H_0:
\begin{pmatrix}
\mu_{1}\\
\mu_{2}\\
\end{pmatrix}
=
\begin{pmatrix}
\mu_{3}\\
\mu_{4}\\
\end{pmatrix}
\end{equation}

the procedure is identical, except that $\bar{x}_1$ are vectors, not single values. 

\subsection{Assessing normality}

One can plot $D^2$ against the appropriate chi-squared distribution:

<<>>=
library(MVA)
#chiplot
@

\subsection*{Analysis using the library ICSNP}

Example code (From ex 3):

\begin{verbatim}
m1<-with(shapedata,
         HotellingsT2(cbind(taper,point) ~ batch))
\end{verbatim}         
     

\section{Time Series}         

\subsection{Smoothing: Moving averages (MAs)} \label{movavg}

At each time point t, take the average of the observations around t, and plot 

\begin{equation}
\frac{1}{2q+1} \sum_{i=-q}^q y_{t+i}\hbox{ against } t
\end{equation}

where $y_t$ is the observation at time $t$.

\textbf{The span} of the MA is the number of values averaged over.

\subsubsection{Linear filter: More general instance of MA (Weighting)}

Taking a moving average amounts to weighting each $y_t$ by 1/span:

\begin{equation}
\sum a_i y_{t+1} \hbox{ against } t \quad \sum a_i = 1
\end{equation}

The moving average is the special case where 

\begin{equation}
a_i= 
\begin{cases}
\frac{1}{2q+1} & \hbox{ if } \mid i \mid \leq q \\
0 & \hbox{otherwise}\\
\end{cases}
\end{equation}

A plausible weight be a=1/12 for monthly measurements, 1/4 for quarters.

Suppose we take a mean at $x=3$: $X_3'=\frac{y_1+y_2+y_3+y_4}{4}$, and then another one $X_3''=\frac{y_2+y_3+y_4+y_5}{4}$.
We could take a mean of these two means:

\begin{equation}
\begin{split}
\frac{1}{2}(X_3'+X_3'') =& \frac{1}{2}(\frac{y_1+y_2+y_3+y_4}{4}+
\frac{y_2+y_3+y_4+y_5}{4})\\
=& \frac{y_1}{8} + \frac{y_2+y_3+y_4}{4}+\frac{y_5}{8}
\end{split}
\end{equation}

The general formula is:

\begin{equation}
x_t = \frac{y_{t-2}}{8} 
+ 
\frac{y_{t-1} + y_t + y_{t+1}}{4}
+
\frac{y_{t+2}}{8}
\end{equation}

\paragraph{Detrending using moving averages}

<<>>=
library(astsa)
library(MASS)
data(jj)
## moving average:
k = c(.5,1,1,1,.5)
(k = k/sum(k)) 
## weights:
fractions(k)
fjj = filter(jj, sides=2, k)  
plot(jj)
## filtered MA:
lines(fjj, col="red")
@
  
<<>>=  
## detrending using MA:
plot(jj-fjj)
@

%\subsubsection{Linear and polynomial estimates of trend}

\subsection{The classical decomposition}

\begin{equation}
\begin{split}
y_t =& m_t + s_t + r_t\\
=& \hbox{trend} + \hbox{seasonal/cyclic} + \hbox{residual/random}
\end{split}
\end{equation}

The trend is computed by $m_t$. We can \textbf{detrend} the 
time series. $m_t$ is estimated from $\hat m_t$.

\begin{equation}
d_t = y-\hat m_t \approx s_t + r_t 
\end{equation}

This is the detrending example shown above with R.

Take logs for multiplicative relationships to get back into linear space:

\begin{equation}
y_t = m_t \times s_t \times r_t
\end{equation}

The decomposition can be done in R as follows:

<<>>=
#str(decompose(jj))
@

Decomposition is useful because:
\begin{enumerate}
\item You can isolate specific components
\item Allows seasonal adjustment (done for monthly economic series and unemployment figures)

\begin{equation}
 y-\hat s_t \approx m_t + r_t 
\end{equation}
\item 
Poor model performance in one component (trend, 
seasonality) can be rectified in isolation.
\end{enumerate}

\subsection{Differencing}

This provides a simple method of removing trend, without explicitly estimating it.

\begin{equation}
\nabla y_t = y_t - y_{t-1}
\end{equation}

Define an operator $B$, called a 
\textbf{backward shift operator}: 

\begin{equation}
B y_t = y_{t-1}
\end{equation}


This allows us to rewrite 

\begin{equation}
\begin{split}
\nabla y_t =& y_t - y_{t-1}\\
=& y_t  - B y_t\\
=& (1- B) y_t\\
\end{split}
\end{equation}

So what we have is \textbf{first-order differencing}, which removes linear trend:

\begin{equation}
\nabla y_t = (1- B) y_t
\end{equation}

<<>>=
## removes linear trend:
plot(diff(jj))
@

\subsubsection{Second-order differencing}

Note that $By_t = y_{t-1}$, and $B^2 y_t = y_{t-2}$.
The power on B is telling you the lag.

\begin{equation}
\begin{split}
\nabla^2 y_t =& (y_t - y_{t-1}) - (y_{t-1} - y_{t-2})\\
=& y_t - 2y_{t-1} + y_{t-2}\\
=&  (1-B)^2 y_t\\
\end{split}
\end{equation}

The last line holds because 

\begin{equation}
\begin{split}
(1-B)^2 y_t =& (1 - 2B + B^2) y_t\\
=& y_t - 2B y_y + B^2 y_t\\
=& y_t - y_{t-1} - y_{t-1} + y_{t-2}
\end{split}
\end{equation}


Second-order differening removes polynomial trend.

\textbf{k-th order differencing}

\begin{equation}
\nabla^k y_t = (1-B)^k y_t 
\end{equation}

\noindent
removes k-th degree polynomial trend. Ususally, k=1 or 
k=2 is enough. Not really practical with k=2 or 3.

``First-, second-, \dots, k-th order differencing are 
sometimes called \textbf{ordinary differencing}''.

If there is \textbf{seasonal variation} with known 
cyclicity k, the 
period can be removed by doing a k-order differencing (Note: subscript on $\nabla$):

\begin{equation}
y_t - y_{t-12}=\nabla_{12} y_t = (1-B^{12}) y_t
\end{equation}

For k=12, we say \textbf{this is differencing with lag 12}, or seasonal differencing if monthly series are involved. 

\paragraph{Exercise}: Show $\nabla \nabla_{12} = 
\nabla_{12}\nabla$, and interpret.

\begin{equation}
\begin{split}
\nabla \nabla_{12} y_t =&  \nabla (y_t - y_{12})\\
=& \nabla y_t -\nabla y_{12}\\
=& (y_t- y_{t-1}) - (y_{t-12}- y_{t-12-1}) \\
=& (y_t- y_{t-12}) - (y_{t-1}- y_{t-1-12})\\
=& \nabla_{12} y_t - \nabla_{12} y_{t-1} \\
=& \nabla_{12} (y_t - y_{t-1})\\
=& \nabla_{12} \nabla y_t \\
 =& \nabla^{13}y_t\\ 
\end{split}
\end{equation}

So, there is k-th order differencing and differencing with lag:

\begin{enumerate}
\item
k-th order diff: $\nabla^{k} y_t=(1-B)^k y_t$ 
\item
diff with lag k: $\nabla_{k} y_t=(1-B^k) y_t = y_t - y_{t-k}$
\end{enumerate}

to-do: Need to improve code examples below:

<<echo=FALSE>>=
dir<-"/Users/shravanvasishth/Dropbox/MScStatistics/2014-2015/MAS6011/Semester2/Data/"

whisk<-read.table(paste(dir,"Whisk.txt",
                        sep=""))
whisk_ts<-ts(whisk,start=c(1980),end=1987,
             frequency=12)
@

<<fig=FALSE>>=
ts.plot(whisk_ts,
        ylab="hectoliters of whiskey 
        per month",
        xlab="month")
@

Another example:
<<>>=
sheftempq<-scan(paste(dir,"Sheftemq.txt",
                        sep=""))
shef_ts<-ts(sheftempq,start=c(1963),end=1978,
             frequency=4)
ts.plot(shef_ts,ylab="temp.",
        xlab="quarter")
@

The decompose function:

<<echo=FALSE>>=
whisk_ts_decomp<-decompose(whisk_ts)
#str(whisk_ts_decomp)
@

<<fig=FALSE>>=
op<-par(mfrow=c(1,3),pty="s")
plot(whisk_ts_decomp$seasonal)
plot(whisk_ts_decomp$trend)
plot(whisk_ts_decomp$random)
@

<<>>=
diffts<-diff(whisk_ts,lag=12)
plot(diffts)
@

\subsection{Auto-correlation function (ACF)}

ACF is not really a function, it's a sequence. It's a tool for 
detecting patterns in data. For each lag h, we compute the standard correlation
coefficient. 


\paragraph{Classical correlation} Suppose we have random variables
X, Y. Then, correlation is:

\begin{equation}
r = \frac{\sum (X_i - \bar{X})(Y_i - \bar{Y})}{
\sqrt{\sum (X_i - \bar{X})^2 \sum (Y_i - \bar{Y})^2} }
\end{equation}

Assuming that $y_t$ is stationary (h is the lag of the ACF), the correlation for each lag h is computed as follows:

\begin{equation}
r_h = \frac{\sum_{t=1}^{n-h} (Y_{t} - \bar{Y})(Y_{t+h} - \bar{Y})}{
\sqrt{\sum_{t=1}^{n} (Y_t - \bar{Y})^2 \sum_{t=1}^{n-h} (Y_{t+h} - 
\bar{Y})^2}}
\end{equation}

<<fig=FALSE>>=
dljj <- diff(log(jj)) 
plot(dljj)
## correlation structure:
## dljj(t-lag) vs dljj(t)
lag.plot(dljj, 9, do.lines=FALSE)  
lag1.plot(dljj, 9)  ## astsa
acf(dljj)
@

The \textbf{sample ACF} is: $h \mapsto r_h$, and the plot is called a
\textbf{correlogram}. The plot is only made for $h\geq 1$. The correlation at h=0 is by definition 1.  

<<fig=FALSE>>=
acf(whisk_ts)
@

\section{Probability models for stationarity and non-stationary time series}

General strategy:

\begin{enumerate}
\item 
Plot series, note features
\item
Remove trend and seasonal components
\item
Choose a model to fit the residuals
\item
To forecast, forecast the residuals, then invert transformations (put back trend and seasonal components) to get forecast of the original series.
\end{enumerate}

The convention usually is $Y_1,\dots, Y_n$ are random variables; and $y_1,\dots, y_n$ are realizations of their values.  In these notes, $y_i$ can refer to both the RV and the realization, depending on context. E.g., when we say $E[y_t]$, this refers to the RV, and $y_t=6$ refers to a realization.

\subsection{Strong stationarity}

This occurs when  the \textbf{joint} distribution $y_{t_1},\dots,y_{t_k}$ is the same 
as that of $y_{t_{1+s}},\dots,y_{t_{k+s}}$, for any $s, k, t_1, \dots, t_k$.

The probability properties of the sequence don't change over time. 
$y_t$ has the same distribution as $y_{t+s}$.

Consequences:

\begin{enumerate}
\item
$\mu_t = E[y_t] = E[y_{t+s}] = \mu_{t+s}=\mu$
\item
$\sigma_t^2 = Var(y_t) = Var(y_{t+s}) = \sigma_{t+s}^2=\sigma^2$
\item
Covariance function (function only of $h$): $\gamma_h = Cov(y_t, y_{t+h}) = Cov(y_{t+s}, y_{t+h+s})$. $\gamma_h$ is the covariance function at lag $h$.

Note that knowing $\gamma_h$ for all $h$ tells us what the variance $\sigma^2$ is too, since $\gamma_0=\sigma^2$.
\end{enumerate}

\subsection{Weak or second-order stationarity}

The means, variances, and covariances are finite, and the following hold:

\begin{enumerate}
\item 
$E[y_t] = \mu$
\item 
$Var(y_t) = \sigma^2$
\item
$Cov(y_t,y_{t+h}) = \gamma_h$
\end{enumerate}

whatever the value of t.

Whenever we say stationarity, we mean weak stationarity.

\subsection{(Theoretical) ACF $\rho_h$}

This is the theoretical analog of the sample ACF.
For a weakly stationary process:

\begin{equation}
\rho_h = Cor(y_t,y_{t+h}) =  
\frac{Cov(y_t,y_{t+h})}{\sqrt{Var(y_t) Var(y_{t+h})}} = \frac{\gamma_h}{\gamma_0}
\end{equation}

Note that $h=0, \pm 1,\dots$.


$\rho_h$ has the properties:

\begin{enumerate}
\item
$-1\leq  \rho_h \leq 1$
\item
$\rho_h = \rho_{-h}$ 
\item
$\rho_0=1$
\item
$\rho_h=0$ if $y_t$ and $y_{t+h}$ independent. 
Note: if $\rho_h=0$, this does not entail $y_t$ and $y_{t+h}$ independent unless both are normally distributed variables.
\end{enumerate}

\subsection{Purely random series (white noise, WN)}

This is a very important example of a stationary process. It's called white noise because, like with white light, all frequencies enter equally.

Such a sequence is called a white noise sequence:

\begin{equation}
y_t = \eps_t \quad E[\eps_t] = 0, Var( \eps_t) = \sigma^2
\end{equation}

$\rho_h=1$ for $h=0$, and 0 otherwise.

\subsubsection{Example of stationary process: A moving average}

See p.\ 14 of Cryer et al book.

\subsubsection{Example of non-statinoary process: Random walk}

Examples: stock prices and Brownian motion.
Not stationary because of non-constant variance, and covariance function $\gamma_{t,s}=t\sigma^2$ does not depend on time lag.

Let $e_1,e_2,\dots$ be an iid sequence of RVs, mean zero and variance $\sigma^2$.
We can write:

\begin{equation}
y_t = y_{t-1} + e_1 = e_1 + \dots+e_t
\end{equation}

\begin{enumerate}
\item $E[y_t] = 0$
\item $Var(y_t) = t\sigma^2$
\item Covariance function. Assume without loss of generality that $1\leq t \leq s$.
Then:

\begin{equation}
\begin{split}
\gamma_{t,s}=&Cov(y_t,y_s) \\
=& Cov(e_1+\dots+e_t,e_1+\dots+e_s)\\
=& Cov(\sum_{i=1}^{t}e_i,\sum_{i=1}^{s}e_j)\\
\end{split}
\end{equation}

If $i\neq j$, then 0, else if $i=j$, it is $Var(e_i)=\sigma^2$.
Since $1\leq t \leq s$, there are t such cases, so 

\begin{equation}
\gamma_{t,s}=t \sigma^2
\end{equation}

\item
The ACF: 

\begin{equation}
\gamma_{t,s}=\frac{\gamma_{t,s}}{\sqrt{\gamma_{t,r}\gamma_{s,s}}}=\frac{t \sigma^2}{\sqrt{t}\sqrt{s}\sigma^2}= \sqrt{\frac{t}{s}}
\end{equation}
\end{enumerate}

%% nice observation in Cryer and Chan p 14:
Note in plot below that even though the theoretical mean is 0 for all time points, the fact that variance increases with time and that neighboring values have correlation nearly 1 means that we should expect long excursions of the process away from the mean of zero. 

<<>>=
ys<-rep(NA,1000)
for(i in 1:1000){
  if (i==1){ys[i]<-rnorm(1)} else{
ys[i]<-ys[i-1]+rnorm(1)
  }
}
plot(1:1000,ys,type="l")
@

Note that differencing: $\nabla y_t = y_t - y_{t-1}$ will make it stationary. See below.









\subsection{Autoregressive (AR) models}

This is the definition of an AR(p) sequence:

\begin{equation}
y_t = a_1y_{t-1} +a_2y_{t-2} +\dots+a_py_{t-p}  + \eps_t 
\end{equation}

$E[\eps_t] = 0,  Var( \eps_t) = \sigma^2, \eps_t \sim WN(0,\sigma^2)$.


\paragraph{Example: Unemployment Figures}

\begin{itemize}
\item
$U_t$: the unemployment total at time t.
\item 
$1-\alpha$: proportion who find a job before the next month. So $\alpha$ is proportion unemployed in next month.
\item 
Then, $U_t$: people unemployed from last month plus people unemployed this month:

$U_t=\alpha U_{t-1} + \eta_t $
\item If $E[U_t]=\mu$ for all t, then, if we subtract $\mu$ from both sides:

\begin{equation}
U_t - \mu = \alpha U_{t-1} -\mu + \eta_t 
\end{equation}

and then add $\alpha \mu - \alpha \mu$ to the RHS:

\begin{equation}
U_t - \mu = \alpha U_{t-1} -\mu + \eta_t + (\alpha \mu - \alpha \mu)
\end{equation}

Rearranging terms and collecting common terms together:

\begin{equation}
U_t - \mu= \alpha( U_{t-1} - \mu)+ (\alpha -1)\mu + \eta_t
\end{equation}

Setting $y_t = U_{t} - \mu$,
and $y_{t-1} = U_{t-1} - \mu$, and 
$\eps_t = (\alpha-1)\mu + \eta_t$,
we can write:

\begin{equation}
y_t= \alpha y_{t-1}+ \eps_t
\end{equation}

\item
Two conditions that must be satisfied:

\begin{itemize}
\item
$E[y_t]=(\alpha-1)\mu+E[\eta_t] = 0$
\item
$E[\eps_t]=0, Var(\eps_t)=\sigma^2$
\end{itemize}
\end{itemize}

\subsubsection{AR(1)}

This is the special case where we regress only on the previous value:

\begin{equation}
y_t= \alpha y_{t-1}+ \eps_t \quad \eps_t \sim WN(0,\sigma^2)
\end{equation}

We can use the backward shift operator (a functional: a function that takes a function as an argument) B, to express AR(1).

By convention, we let $B^0 y_t = 1$. This allows us to write, more generally:

\begin{equation}
%By_t = y_{t-1} \quad \hbox{ or } 
B^{i}y_t = y_{t-i}, i=1,\dots,t, 0 \leq i \leq t 
\end{equation}

Then, we can write 

\begin{equation}
y_t= \alpha y_{t-1}+ \eps_t 
\end{equation}

as

\begin{equation}
y_t= \alpha By_t+ \eps_t 
\end{equation}

Rearranging to get $\eps_t$ on RHS:

\begin{equation}
y_t - \alpha By_t= \eps_t \Rightarrow y_t(1 - \alpha B)= \eps_t 
\end{equation}

\begin{equation}
\phi(B)y_t = \eps_t \quad \phi(B)=(1 - \alpha B)
\end{equation}

Here, $\phi(B)$ is a polynomial of degree one (a linear function of B).

We can express $y_t$ as follows:

\begin{equation}
y_t = \phi(B)^{-1}\eps_t \quad \phi(B)=(1 - \alpha B)
\end{equation}

\paragraph{Basic properties of AR(1) processes}\label{basicpropertiesAR1}

\begin{enumerate}
\item \textbf{MA($\infty$) representation}: Consider AR(1):

\begin{equation}
\begin{split}
y_t=& \alpha y_{t-1}+ \eps_t \\
=& \alpha (\alpha y_{t-2}+ \eps_{t-1}) + \eps_t \\
=& \alpha (\alpha (\alpha y_{t-3}+ \eps_{t-2})+ 
\eps_{t-1}) + \eps_t \\
=& \dots\\
=& \alpha^t y_0 + \sum_{i=0}^{t-1} \alpha_i \eps_{t-i}  
\end{split}
\end{equation}

As $t\rightarrow \infty$, if $\mid \alpha \mid < 1$ and $y_0$ finite, we get:

\begin{equation}
\sum_{i=0}^{\infty} a^i \eps_{t-i}
\end{equation}

Thus, as long as $\mid a_i\mid <1$, we have a \textbf{minimum moving average} representation of AR(1):

\begin{equation}
y_t = \sum_{i=0}^{\infty} a^i \eps_{t-i}
\end{equation}

[Recall definition of MA's, section~\ref{movavg}.]

This will make it easier to compute mean, variance, and acf.

\item \textbf{Expectation, variance and acf}:


\begin{equation}
E[y_t] = \sum_{i=0}^{\infty} \alpha^i E[\eps_{t-i}] = 0
\end{equation}

\begin{equation}
Var(y_t) = \sum_{i=0}^{\infty} \alpha^{2i} 
\explain{Var(\eps_{t-i})}{\hbox{indep. because white noise}} = 
\frac{\sigma^2}{1-\alpha^2} \quad \mid \alpha \mid < 1
\end{equation}

The above follows due to the geometric series (infinite sum).

The covariance: (Recall: Cov(X,Y)=E[XY] - E[X]E[Y])

\begin{equation}
\gamma_h = E[y_ty_{t+h}]-\explain{E[y_t]}{=0}\explain{E[y_{t+h}]}{=0} =
E[y_ty_{t+h}]
\end{equation}

Since $E[y_t] = \sum_{i=0}^{\infty} \alpha^i \eps_{t-i}$ and 
$E[y_{t+h}] = \sum_{j=0}^{\infty} \alpha^j \eps_{t+h-j}$,

\begin{equation}
\gamma_h = E[y_ty_{t+h}]-\explain{E[y_t]}{=0}\explain{E[y_{t+h}]}{=0}
\end{equation}

\begin{equation}
\begin{split} \label{expectationytytplush}
E[y_ty_{t+h}] =& 
E[\sum_{i=0}^{\infty} \alpha^i \eps_{t-i}
\sum_{j=0}^{\infty} \alpha^j \eps_{t+h-j}]\\
=& E[\sum_{i,j=0}^{\infty} \alpha^i \eps_{t-i}
\alpha^j \eps_{t+h-j}]\\
\end{split}
\end{equation}

\label{zeroexpectation}
If $t-i \neq t+h -j$, we have $E[\eps_{t-i}\eps_{t+h-j}]=0$ because the errors are independent.
And if $t-i = t+h -j$, this implies that $j=i+h$. Consequently, for this case, we can write

\begin{equation}
\begin{split}
E[\eps_{t-i}\eps_{t+h-j}] =& 
E[\eps_{t-i}\eps_{t+h-(i+h)}]\\
=& E[\eps_{t-i}\eps_{t-i)}]\\
=& E[\eps_{t-i}^2]=Var(\eps_{t-i})=\sigma^2
\end{split}
\end{equation}

The last line above follows because 
$Var(\eps_{t-i})=E[\eps_{t-i}^2]-E[\eps_{t-i}]^2=E[\eps_{t-i}^2]$.

Now, going back to equation~\ref{expectationytytplush},
we can write $E[\sum_{i,j=0}^{\infty} \alpha^i \eps_{t-i}
\alpha^j \eps_{t+h-j}]$ as:

\begin{equation}
\begin{split}
E[y_ty_{t+h}] =& \sigma^2 \sum_{i=0}^{\infty} \alpha^{i}\alpha^{i+h} \quad j=i+h \\
\end{split}
\end{equation}

This amounts to saying that

\begin{equation}
\begin{split}
\sigma^2 \sum_{i=0}^{\infty} \alpha^{i}\alpha^{i+h} =& 
\sigma^2 \sum_{i=0}^{\infty} \alpha^{i}\alpha^{i}\alpha^h\\
=& \sigma^2 \alpha^h \sum_{i=0}^{\infty} \alpha^{2i}
\end{split}
\end{equation}

So, 
\begin{equation}
\begin{split}
E[y_ty_{t+h}] =& \sigma^2 \alpha^h\sum_{i=0}^{\infty}  \alpha^{2i}\\
=& \frac{\sigma^2\alpha^h}{1-\alpha^2} \quad \mid \alpha \mid < 1
\end{split}
\end{equation}

So, we have:

\begin{equation}
\gamma_h = \frac{\sigma^2\alpha^h}{1-\alpha^2}
\end{equation}


ACF: 

\begin{equation}
\begin{split}
\rho_h =& \frac{\gamma_h}{\gamma_0}\\
=& \frac{\cancel{\sigma^2} \alpha^h/\cancel{(1-\alpha^2)}}{\cancel{\sigma^2}
\alpha^0/\cancel{(1-\alpha^2)}}\\
=& \alpha^{\mid h \mid} \quad h=0, \pm 1, \dots \mid \alpha \mid < 1\\
\end{split}
\end{equation}

%[All that hard work, for this?]

\textbf{So the mean, variance, and ACF do not depend on time t.} So, the $y_t$
satisfies the conditions for stationarity.  


\end{enumerate}

<<>>=
a<-seq(0.01,.99,by=.1)

h<-seq(0,100,by=1)

op<-par(mfrow=c(5,2),pty="s")
for(alpha in a){
plot(h,alpha^h/(1-alpha^2),type="l",main=alpha)
}

nega<--1*a
op<-par(mfrow=c(5,2),pty="s")
for(alpha in nega){
plot(h,alpha^h/(1-alpha^2),type="l",main=alpha)
}
@

\textbf{Note that $\mid \alpha \mid<1$ (in order for the series to converge).} This fact appears below as well, section~\ref{arpolynomial}.

\paragraph{Example of non-convergence when $ \alpha = 1$: Random Walk}


If $\alpha=1$, then the AR(1) doesn't 
have stationarity anymore:

The definition of AR(1) is:

\begin{equation}
y_t = \alpha y_{t-1} + \eps_t
\end{equation}

<<>>=
nsim<-10000
ys<-rep(NA,nsim)
ys[1]<-rnorm(1)

for(i in 2:nsim){
ycurrent<-ys[i-1]+rnorm(1)
ys[i]<-ycurrent
}
plot(ts(ys))
@

If $\alpha=1$, then 

\begin{equation}
y_t = y_{t-1} + \eps_t
\end{equation}

The expectation of $y_t$:

\begin{equation}
E[y_t] = E[y_{t-1}] + E[\eps_t] = E[y_{t-1}] \forall t
\end{equation}

Therefore, $E[y_t]=E[y_1]=constant$. This satisfies the first condition for
stationarity.

But the variance is:

\begin{equation}
Var(y_t) = Var(y_{t-1}) + Var(\eps_t)
\end{equation}

We have to establish here that $Var(y_{t-1})$ and $Var(\eps_t)$ are independent. This is so because, we can write:

\begin{equation}
y_{t-1} = y_{t-2}+\eps_{t-1}
\end{equation}

So, $y_{t-1}$ is a function of $\eps_{t-1},\eps_{t-2},\dots$. And
$\eps_{t-1}$ is independent of $\eps_{t}$ as $t-i \neq t$, for $i=1,2,\dots$.

Due to the independence of $Var(y_{t-1})$ and $Var(\eps_t)$, it follows that:

\begin{equation}
Var(y_t) = Var(y_{t-1}) + Var(\eps_t)
=  Var(y_{t-1}) + \sigma^2
\end{equation}

This proves that the variance will increase with t; it will go to infinity in the limit.
This violates stationarity unless $\sigma^2=0$. Note that if 
$\sigma>0$ and $Var(y_{t-1})$ is infinite, then we have stationarity.

Writing the above recursively:

\begin{equation}
\begin{split}
Var(y_t) =& Var(y_{t-1}) + Var(\eps_t)\\
=&  Var(y_{t-1}) + \sigma^2\\
=&  Var(y_{t-2}) + \sigma^2+\sigma^2\\
=& Var(y_{1})+\underbrace{\sigma^2+\dots+\sigma^2}_\text{t-1 times}\\
=& Var(y_{0})+\underbrace{\sigma^2+\dots+\sigma^2}_\text{t times}\\
=&Var(y_{0})+t\sigma^2
\end{split}
\end{equation}

So, as $t\rightarrow \infty$, $Var(y_t)\rightarrow \infty$, since $\sigma^2>0$. Actually, we don't even need to go so far as to find the limit, we just need to note that $Var(y_t)$ depends on $t$, so the sequence 
$\{y_t\}$ is not stationary. 
\textbf{This kind of model is relevant in finance (stock prices).}

\textbf{Note that for AR(1) in general, $Var(y_t)<\infty \Leftrightarrow$ stationarity}.

Note that differencing will reduce $y_t$ to stationarity:

\begin{equation}
\nabla y_t = y_t - y_{t-1} = \cancel{y_{t-1}} + \eps_t - \cancel{y_{t-1}} =
 \eps_t
\end{equation}

$Var(\nabla y_t) = Var(y_{t-1} - y_{t-1} + \eps_t) = Var(\eps_t) = \sigma^2$.

\paragraph{Example} Note that a negative alpha will lead to the acf 
``oscillating'' between positive (even) and negative (odd) values.

\begin{equation}
y_t = -0.8\times y_{t-1}+\eps_t
\end{equation}

<<>>=
y<-arima.sim(100,model=list(ar=-.8))
ts.plot(y)
acf(y)
@

\subsection{AR(p), $p>1$}\label{arpprocess}

Given an AR(p) process:

\begin{equation} 
y_t = a_{1}y_{t-1} + \dots + a_p y_{t-p} + \eps_t 
\end{equation}

The general approach will be to get the white noise to the right, and the y's to the LHS:

\begin{equation}
\begin{split}
~& y_t - a_{1}y_{t-1} - \dots - a_p y_{t-p} =  \eps_t \\
\Leftrightarrow & y_t - a_1 B y_t - \dots - a_p B^p y_t = \eps_t \quad \hbox{ recall } B^i y_t =  \eps_t\\
\Leftrightarrow& \underbrace{(1-a_1 B - \dots - a_p B^p)}_\text{$\phi(B)$} 
y_t = \eps_t\\
\Leftrightarrow& \phi(B) y_t = \eps_t
\end{split}
\end{equation}

This gives us the moving average representation.

The $MA(\infty)$ representation is

\begin{equation}
y_t = \sum_{i=1}^{\infty} \psi_i \eps_t \quad \hbox{ where } \psi_i \hbox{ are appropriate constants }
\end{equation}

The polynomial $\phi(B) y_t = \eps_t$ is extremely important, because it determines whether we have a stationary process or not.

\subsubsection{The Autoregressive Polynomial}\label{arpolynomial}

\begin{equation}
\phi(x) = 1- \alpha_1 x - \dots - \alpha_p x^p = 1- \sum_i^{p} a_i x^i 
\end{equation}

If $\phi(x)=0$, then $\mid x \mid >1$.

\begin{definition}
An AR(p) process is causal iff all roots of $\phi(x)= 0$ lie outside the unit circle.
\end{definition}

In sum:

\begin{enumerate}
\item The process

\begin{equation} 
y_t = a_{1}y_{t-1} + \dots + a_p y_{t-p} + \eps_t 
\end{equation}

is stationary iff the roots of the polynomial $\phi(x)$ lie outside the unit circle, i.e., $\phi(x) = 0 \Rightarrow \mid x \mid > 1$. (x can be real or complex)
\item
An AR(p) process is causal if 
\begin{enumerate}
\item it is stationary
\item and can be represented in terms of the white noise variable $\eps_i$ in $MA(\infty)$ form:
\begin{equation}
y_t = \sum_{i=1}^{\infty} \psi_i \eps_{t-i} 
\end{equation}

Proof of above is in Brockwell and Davis 2002.

The sequence $\{\psi_i \}$ depends on the AR parameters $a_j$ for $j = 1,\dots,p$. (the change in index is not a typo; think about it.)

\end{enumerate}

\end{enumerate}


\paragraph{Example} AR(1)

In AR(1)

\begin{equation}
y_t = ay_{t-1} + \eps_t
\end{equation}

was stationary if $\mid a \mid < 1$. If p=1, then the AR polynomial is 

$\phi(x)= 1- ax$

The root is $\phi(x)=0\Rightarrow x=\frac{1}{\mid a\mid}$. This implies that $\mid a\mid<1$. See discussion above on $\mid a\mid <1$ (section~\ref{basicpropertiesAR1}).

\subsubsection{Deriving ACF for AR(p): The Yule-Walker (difference) equations}

We are going to derive $\gamma_h$.

Recall that (we proved this earlier) that 
$\gamma_h = E[y_{t-h} y_t]=\gamma_{-h}$, because ACF depends only on lag, not on time t.

\begin{equation}
\begin{split}
\gamma_h =& Cov(y_{t-h} y_t)\\
=& E[y_{t-h} y_t] \quad \hbox{ recall } E[y_t]=0\\
\end{split}
\end{equation}
 
Replace $y_t$ with its expansion in AR(p). I will replace $\alpha$ with $a$ for convenience:

\begin{equation}
E[y_{t-h} y_t] = E[y_{t-h} (a_1y_t+\dots+a_p 
y_{t-p}+\eps_t)]
\end{equation}

Multiplying out the terms:

\begin{equation}
\begin{split}
E[y_{t-h} (a_1y_{t-1}+\dots+a_p 
y_{t-p}+\eps_t)] =& \\
a_1 E[y_{t-h}y_{t-1}]+ \dots ~&  \\
+ a_p E[y_{t-h}y_{t-p}]+
E[y_{t-h} \eps_t] ~&\\
\end{split}
\end{equation}

We will now work out $E[y_{t-h}y_{t-1}]$. 
We can rewrite this as $E[y_{(t-1)-(h-1)}y_{t-1}]$. Rewrite $t-1$ as $t*$.

\begin{equation}
\begin{split}
E[y_{t-h}y_{t-1}] =& E[y_{(t-1)-(h-1)}y_{t-1}]\\
=& E[y_{t*-(h-1)}y_{t*}]\\
\end{split}
\end{equation}

The model is causal; the ACF doesn't depend on t, so 

\begin{equation}
E[y_{t*-(h-1)}y_{t*}]=\gamma_{h-1}
\end{equation}

So, we are going to get:

\begin{itemize}
\item $E[y_{t*-(h-1)}y_{t*}]=\gamma_{h-1}
$
\item \dots
\item $E[y_{(t-p)-(h-p)}y_{t-p}]=
E[y_{t*-(h-p)}y_{t*}]=\gamma_{h-p}$
\end{itemize}

Next, we show that $E[y_{t-h}]E[\eps_t]=0$.
Since $y_t$ is causal, 
$y_{t-h}$ is written as a linear combination 
of $\eps_{t-h}, \eps_{t-h-1},\dots$, and each of these $\eps$ are independent of $\eps_t$ because the indices are different; 
i.e., $t-h\neq t, t-h-1\neq t,\dots$,
since $\{\eps_t\}$ is white noise.

Hence $y_{t-h}$ is independent of $\eps_t$.

%Since $y_{t-h}$ can be written as a linear combination of all $\eps$, the last term 
%$E[y_{t-h} \eps_t]=0$: 
%$E[y_{t-h}\eps_t]= E[y_{t-h}]E[\eps_t]=0$.

From the above results, we can write:

\begin{equation}
\gamma_h= E[y_{t-h}y_t] = a_1 \gamma_{h-1}+
\dots+a_p \gamma_{h-p}
\end{equation}

So, ACF of AR(p) is given by

\begin{equation}
\rho_h=\frac{\gamma_h}{\gamma_0}=
\frac{a_1 \gamma_{h-1}+ \dots+a_p \gamma_{h-p}}{\gamma_0}
\end{equation}

In other words:

\begin{equation}
\rho_h=a_1 \rho_{h-1}+ \dots+a_p \rho_{h-p}
\end{equation}

The above is the \textbf{Yule-Walker (difference) equation}.

For example, an AR(2) process:
$y_t = 0.5 y_t + 0.25 y_{t-2} + \eps_t$.

<<>>=
## not sure if this is right: 
#y<-arima.sim(100,model=list(ar=c(0.5,0.25)))
#ts.plot(y)
#acf(y)
@

\subsection{MA processes of order q: MA(q)}

\begin{equation}
y_t = \sum_{i=0}^{q} \beta_i \eps_{t-i} = \beta_0 \eps_t +
\beta_1 \eps_{t-1} + \dots +
\beta_q \eps_{t-q}
\end{equation}

Assume that $\beta_0=1$. 

Why do we call it a Moving Average (MA) process? If you consider $\beta_i$ as weights, then this equation is reminiscent of the MAs. But the MA process, confusingly, has nothing to do with Moving Averages discussed earlier in section~\ref{movavg}.
This equation is about estimation. 

\subsubsection{The expectation}

As before, the mean of $y_t=0$.

\begin{equation}
E[y_t] = \sum \beta_1 E[\eps_{t-i}] = 0 \hbox{ since } E[\eps_{t-i}]=0
\end{equation}

\subsubsection{Variance}

\begin{equation}
\begin{split}
Var(y_t) =& Var(\sum_{i=0}^{q} \beta_i \eps_{t-i})\\
=& \sum_{i=0}^{q} \beta_i^2 Var(\eps_{t-i}) \quad \hbox{ because } \eps_{t-i},\eps_{t} \hbox{ are indep.\ RVs }\\
=& \sigma^2 \sum_{i=0}^{q} \beta_i^2 \\
=& \sigma^2 (1+\beta_1^2+\dots+\beta_q^2)
\end{split}
\end{equation}

Note that this implies that 

\begin{equation}
\gamma_0 = Cov(y_t y_{t+0}) =  Var(y_t) = \sigma^2 \sum_{i=0}^{q} \beta_i^2
\end{equation}




\subsubsection{ACF of MA(q)}

\begin{equation}
\begin{split}
\gamma_h = & Cov(y_t y_{t+h}) \\
= & E[y_t y_{t+h}]\\
\end{split}
\end{equation}

Since $y_t = \sum_{i=0}^{q} \beta_i \eps_{t-i}$
and $y_{t+h} = \sum_{j=0}^{q} \beta_j \eps_{t+h-j}$,
we can write the last line above as:

\begin{equation}
\begin{split}
 E[y_t y_{t+h}] = & E[\sum_{i=0}^{q} \sum_{j=0}^{q}
 \beta_i \beta_j \eps_{t-i}\eps_{t+h-j} ]\\
 = & \sum_{i=0}^{q} \sum_{j=0}^{q}
 \beta_i \beta_j E[\eps_{t-i}\eps_{t+h-j}]\\
\end{split}
\end{equation}

Only when $t-i = t+h-j$, and consequently $j=i+h$, do we have a non-zero expectation. When $t-i \neq t+h-j$, expectation of the $\eps$ is 0. (see page~\pageref{zeroexpectation}).

When $E[\cdot]\neq 0$, $E[\eps_{t-i}^2] = Var(\eps_{t-i})=\sigma^2$.
So, 

\begin{equation}
\begin{split}
\gamma_h = & Cov(y_t y_{t+h}) \\
= & E[y_t y_{t+h}]\\
= & \sum_{i=0}^{q-h} \beta_i \beta_{i+h} \sigma^2 \\
=& \sigma^2 \sum_{i=0}^{q-h} \beta_i \beta_{i+h}\\
=& \sigma^2 \sum_{i=0}^{q-h} \beta_i \beta_{i+h}\\
\end{split}
\end{equation}

The upper bound in the summation is $q-h$ because we have $i+h$ as a subscript, and $(q-h) + h = q$, which is the maximum value we can have. Hence, i can only have maximal value $q-h$.

So:

\begin{equation}
\gamma_h= 
\begin{cases}
 \sigma^2 \sum_{i=0}^{q-h} \beta_i \beta_{i+h} & \hbox{ if } 
t-i = t+h-j  \\
0 & \hbox{otherwise}\\
\end{cases}
\end{equation}

It follows that 

\begin{equation}
\rho_h = \frac{\gamma_h}{\gamma_0} = \frac{\cancel{\sigma^2} \sum_{i=0}^{q-h} \beta_i \beta_{i+h}}{\cancel{\sigma^2} \sum_{i=0}^{q}\beta_i}
= \frac{\sum_{i=0}^{q-h} \beta_i \beta_{i+h}}{\sum_{i=0}^{q}\beta_i}
\end{equation}

Thus,

\begin{equation}
\rho_h= 
\begin{cases}
0 & \hbox{ for } h>q\\
\frac{\sum_{i=0}^{q-h} \beta_i \beta_{i+h}}{\sum_{i=0}^{q}\beta_i} & \hbox{ for }  h\leq q\\
\end{cases}
\end{equation}

So, we could in principle use ACF to identify which $q$ is appropriate, because as soon as $h>q$, the ACF function will a value of $\rho_h=0$.

<<>>=
y<-arima.sim(1000,model=list(ar=.9))
plot.ts(y)
acf(y)
@

The above kind of plot is a very useful tool for identifying AR(q) produces.

\paragraph{Notes}

\begin{enumerate}
\item $q\rightarrow \infty \Rightarrow MA(\infty)$ is only used to represent AR(1).
\item 
Stationarity holds iff $Var(y_t) < \infty$, that is, $\sum_{i=0}^{q} \beta_i^2 < \infty$.
\end{enumerate}

So, we can identify an appropriate model by looking at the ACF. We want a 1-to-1 relationship between ACF and model. But we have a problem: the ACF is non-unique.

\subsubsection{Non-uniqueness of ACF}

Consider an MA(1) process:

\begin{equation}
y_t = \beta_0\eps_t + \beta_1 \eps_{t-1}
=\eps_t + \beta_1 \eps_{t-1}
\end{equation}

The ACF is 
$\rho_h = \frac{\beta_1}{1+\beta_1^2}$ when h=1 and 0 otherwise.

Suppose now that we have a second MA(1) model:

\begin{equation}
x_t =\eps_t + \frac{1}{\beta_1} \eps_{t-1}
\end{equation}

The ACF now is 

\begin{equation}
\rho_h' = 
\frac{\frac{1}{\beta_1}}{1+\frac{1}{\beta_1^2}}
= \frac{\beta_1}{1+\beta_1^2}= \rho_h !!!
\end{equation}

So, two clearly different models have the same ACF: looking at the ACF will not necessarily lead to a unique model.

\subsubsection{Invertible process}

If we want to use ACF to identify a unique model, we can do the following. Take an MA(1) model:

\begin{equation}
y_t = \eps_t + \beta_1 \eps_{t-1}
\end{equation}

Let 

\begin{equation}
\eps_t = y_t  - \beta_1 \eps_{t-1}  
\end{equation}

and 

\begin{equation}
\eps_{t-1} = y_{t-1}  - \beta_1 \eps_{t-2}  
\end{equation}

Expanding out $\eps_{t-1}$ in the following equation

\begin{equation}
y_t = \eps_t + \beta_1 \eps_{t-1}
= \eps_t + \beta_1(y_{t-1}  - \beta_1 \eps_{t-2})
\end{equation}

This is going to be an infinite series:

\begin{equation}
y_t = - \sum_{i=1}^{\infty} (-\beta_i)^{i} y_{t-1} + \eps_t 
\end{equation}

This is an $AR(\infty)$ iff $\mid \beta_1\mid < 1$. This rules out second model above as $\mid \frac{1}{\beta} \mid = \mid \beta' \mid > 1$.

\section{ARMA(p,q) processes}

\begin{definition}
$y_t$ is an ARMA(p,q) process if it is stationary and satisfies:

\begin{equation}
y_t = 
\underbrace{a_1 y_{t-1} + \dots + a_p y_{t-p} + \eps_{t}}_\text{AR(p)} + \underbrace{b_1 \eps_{t-1} + \dots + b_q \eps_{t-q}}_\text{MA(q)}
\end{equation}
\end{definition}

We can simplify this by using the backward shift operator. 

Let $\phi(x)=1-a_1 x - \dots - a_p x^p$ and $h(x)=1+b_1 x + \dots + b_q x^q$.

Since 

\begin{equation}
y_t = 
a_1 y_{t-1} + \dots + a_p y_{t-p} + e_t
\end{equation}

and assuming that $By_t = y_{t-1}$, we can write:

\begin{equation}
y_t = 
a_1 By_t + a_2 B^2 y_t \dots + a_p B^py_t + \eps_t
\end{equation}

Moving all terms but $e_t$ to LHS:

\begin{equation}
y_t -a_1 By_t - a_2 B^2 y_t \dots - a_p B^py_t = 
  \eps_t
\end{equation}

we get

\begin{equation}
y_t\underbrace{(1 -a_1 B - a_2 B^2  \dots - a_p B^p}_\text{$\phi(B)$} = 
  \eps_t
\end{equation}


Similarly, (and recalling that we define $B^0 y_t = 1$), 
we can define $B\eps_{t} = \eps_{t-1}$ and write:

\begin{equation}
b_0 \eps_t + b_1 \eps_{t-1} + \dots + b_q \eps_{t-q}
\end{equation}

as

\begin{equation}
b_0 B^0 \eps_t + b_1 B\eps_{t} + \dots + b_qB^q\eps_{t}
\end{equation}

or as

\begin{equation}
\underbrace{(1 + b_1 B + \dots + b_qB^q)}_\text{h(B)}\eps_{t}
\end{equation}

So, we can write an ARMA(p,q) process as:

\begin{equation}
\phi(B)y_t = h(B)\eps_{t}
\end{equation}

Notice that this yields a stationary $MA(\infty)$ representation:

\begin{equation}
y_t = (\phi(B))^{-1}h(B)\eps_{t} = \sum_{i=0}^{\infty} \psi_i \eps_{t-i}
\end{equation}

$\phi(B)$ (p parameters) is the \textbf{characteristic polynomial} of the AR model, and 
$h(B)$ (q+1 parameters) is the \textbf{characteristic polynomial} of the MA model.

\textbf{We get a stationary $MA(\infty)$ representation}

\begin{equation}
y_t = (\phi(B))^{-1} h(B) \eps_t = \sum_{i=0}^{\infty} \psi_i \eps{t-i}
\end{equation}

iff all roots of $\phi(x)=0$ lie outside the unit circle. This process is called \textbf{causal}. Recall that causality implies stationarity; so if you need to check for statiionarity, check for causality.

\textbf{We get a stationary $AR$ representation}

\begin{equation}
\eps_t = \phi(B) (h(B))^{-1} \y_t = \sum_{j=0}^{\infty} \delta_j y_{t-j}
\end{equation}

iff all roots of h(x)=0 lie outside unit circle. The process is said to be \textbf{invertible}. \textbf{If this part is invertible, then the ARMA(p,q) process is invertible.}

\subsection{ACF of an ARMA(p,q) process}

The ACF of the AR part will be the ACF of the ARMA process.

This is because, when we compute the acf, we have to compute the expectation of
$y_{t-h}y_t$. Now,

\begin{equation}
\begin{split}
~& y_{t-h}y_t = 
y_{t-h}(a_1 y_{t-1} + \dots + a_p y_{t-p} +\eps_{t}) \\
~&+ \underbrace{y_{t-h}(b_1 \eps_{t-1} + \dots + b_q \eps_{t-q})}_\text{Expectation 0}\\
\end{split}
\end{equation}


If $h>q$, then $y_{t-h}$ is uncorrelated with $\eps_t, \eps_{t+1},\dots,\eps_{t+q}$.
This is because $y_{t-h}$ can be expressed in terms of $\eps$, and each of these will be independent from the $\eps$ in the MA part of the equation above. So, the part in underbrace will have expectation 0.

The AR part will determine $\gamma_h$, and this can be computed as earlier.

\textbf{We will not discuss the case where $h\leq q$ in the course.}

Example: ARMA(1,1):

\begin{equation}
y_t = 0.8 y_{t-1} + \eps_t + 0.9 \eps_{t-1}
\end{equation}

<<>>=
y <- arima.sim(100, model=list(ar=0.8,ma=0.9))
ts.plot(y)
acf(y)
@

\section{Non-stationary ARIMA}

Stationarity is only studied for convenience, because it has nice properties. But real data is non-stationary.

We will reduce a NS model to a stationary model by differencing, model the $\nabla$ series by a causal or invertible process, and then transform back to the NS process. This is the Box-Jenkins approach.

Recall that 

\begin{equation}
\nabla^k y_t = (1-B)^k y_t 
\end{equation}

Let $y_t$ be the time series. If we apply d-th order differncing to it, we get

\begin{equation}
x_t =  (1-B)^d \eps_t 
\end{equation}

$x_t$ is now a stationary process, and we can define an ARMA model for it.

\begin{definition}
For integer $d\geq 0$, the series $y_t$ is an ARIMA(p,d,q) process (integrated autoregressive moving average process of order p,d,q) if the d-times differenced $y_t$, call it $x_t=(1-B)^d y_t$, is ARMA(p,q).

That is:

\begin{equation}
\begin{split}
~& \phi(B)x_t =  h(B) \eps_t\\
~& \phi(B)(1-B)^d y_t = h(B)\eps_t
\end{split}
\end{equation}

Now, $\phi_1 (B)  = \phi(B)(1-B)^d $  is of order p+d. 
One root of $\phi_1 (B)$ is 1, and so $y_t$ is not stationary.
\end{definition}

\subsection{Seasonal ARIMA: SARIMA}

Note: we will use D for seasonal differncing, instead of d. D is only rarely greater than 2.

Recall: 
\begin{enumerate}
\item
$\nabla_s = 1-B^s$, so $\nabla_s y_t = y_t - y_{t-s}$. For monthly data, s=12. Usually D=1 suffices.
\item
$\nabla^d=(1-B)^d$.
\end{enumerate}

Let $x_t = \nabla_s^{D} y_t$ be a D-times seasonally differenced series, where s is the length of the seasonal variation.

In this case,

\begin{equation}
\begin{split}
x_t =&  \nabla_s^{D} y_t\\
=& (\nabla_s)^{D} y_t\\
=& (1-B^s)^D y_t \quad \hbox{ as } 
\nabla_s = 1-B^s 
\end{split}
\end{equation}

If $x_t$ is ARMA(P,Q) then $y_t$ is ARIMA(P,D,Q)$_s$.

If the data $y_t$ is non-stationary not due to seasonality but due to trends (for example),  then we can do differencing to get stationarity: 
 
 \begin{equation}
x_t = \nabla^d \nabla_s^D y_t 
 \end{equation}

Replacing each of the terms with their expansions:

\begin{equation}
x_t = \underbrace{(1-B)^d}_\text{$\nabla_d$} \underbrace{(1-B^s)^D }_\text{$\nabla_s^D$}y_t
\end{equation}
 
 Now we assume that $x_t$ follows an ARMA(P,Q) model for its seasonal terms (those lagged by s) and an ARMA(p,q) for its nonseasonal terms. 
This means that there 

\begin{equation} 
\Phi_s (B^s) x_t = H_s(B^s)h(B)\eps_t
\end{equation}

Expanding out $x_t$:

\begin{equation} \label{sarimaformula}
\underbrace{\Phi_s(B^s)}_\text{seasonal}\underbrace{\phi(B)}_\text{AR poly.}\underbrace{(1-B^s)^D y_t}_\text{stationary} ] = \underbrace{H_s (B^s)}_\text{seasonal} \underbrace{h(B)}_\text{MA poly.}\eps_t 
\end{equation}
 
$\Phi,\phi, H, h$  are polynomials.

Such a model is called seasonal ARIMA(p,d,q)$\times$
(P,D,Q)$_s$ with period s. 
p,d,q refers to the trend, P,D,Q to the seasonal part.

BTW, note how the Backward shift operator simplifies the notation.

The application of this formula will be: Given a model SARIMA(p,d,q)$\times$
(P,D,Q)$_s$ with some instantiated values, write down the form of the model in the form $y_t=\dots$. Or vice versa. 

\textbf{Example}:
Write down the model SARIMA(1,1,0)$\times$ (0,1,1)$_4$ as $y_t=\dots$.

\begin{enumerate}
\item Step 1: list all variables:

\begin{table}[htdp]
\begin{center}
\begin{tabular}{cc}
Trend & Seasonal\\
p=1 & P=0\\
d=1 & D=1\\
q=0 & Q=1\\
    & s=4
\end{tabular}
\end{center}
\end{table}%

These variables will determine what the polynomials should be. 

\item Step 2: Replace values of s and D in formula in equation~\ref{sarimaformula}:

\begin{equation} \label{sarimaformula2}
\begin{split}
~& \underbrace{\Phi_s(B^4)}_\text{P=0 so 1}\underbrace{\phi(B)}_\text{p=1 so $1-aB$}\underbrace{(1-B^4)^1 y_t}_\text{stationary} ] \\
~& = \underbrace{H_s (B^4)}_\text{Q=1 so $1+bB^4$} \underbrace{h(B)}_\text{q=0 so 1}\eps_t 
\end{split}
\end{equation}

This gives us:

\begin{equation}
1(1-aB)(1-B^4)(1-B)y_t = (1+bB^4)\eps_t
\end{equation}

After some algebra, we get:

\begin{equation}
\begin{split}
~& (1-(a+1)B + aB^2-B^4 + (a+1)B^5 -aB^6) y_t \\
~& = (1+bB^4)\eps_t
\end{split}
\end{equation}

After some more algebraic manipulation,

\begin{equation}
\begin{split}
~& y_t = (a+1) \underbrace{y_{t-1}}_\text{$By_t$} + ay_{t-2} - y_{t-4} + (a+1) t_{t-5} - a y_{t-6}\\
~&= \eps_t + b\underbrace{\eps_{t-4}}_\text{$B^4$}
\end{split}
\end{equation}

Move everything but $y_t$ to RHS:

\begin{equation}
\begin{split}
y_t =& (a+1) y_{t-1} - ay_{t-2} + y_{t-4} - \\
~& (a+1)y_{t-5} + ay_{t-6} + \eps_t + b\eps_{t-4}
\end{split}
\end{equation}

\end{enumerate}

More examples are in the problem sets.

\section{Inference}

The Box-Jenkins iterative approach:

\begin{enumerate}
\item Identify initial values of p,d,q and P,D,Q
\item Estimate ARIMA parameters
\item  Diagnosis and model criticism
\item Modify the model based on 3 above (i.e., change p,d,q and P,D,Q) and go back to 2.
\end{enumerate}

\subsection{Identifying model}

\begin{figure}[H]
\includegraphics[width=8cm,height=8cm,angle=-90]{diggleplot}
\caption{Plot after Diggle.}\label{fig:diggleplot}
\end{figure}

Six ways to identify model:

\begin{enumerate}
\item Time plot: can indicate non-stationarity, seasonality, need to difference

<<>>=
## shows seasonality:
ts.plot(shef_ts,ylab="temp.",
         xlab="quarter")
@

\item ACF/Correlogram: can indicate non-stationarity, seasonality

<<>>=
## shows seasonality:
acf(shef_ts)
@

\begin{enumerate}
\item An ACF not decaying to 0 suggests non-stationarity
\item An ``oscillating'' ACF suggests seasonality (see above \texttt{shef} example).
\end{enumerate}
\item Test for white noise: Plot 95\% CIs in Correlogram, if sample autocorrelations $r_h$ lie outside intervals, then not white noise.


\underline{Details}: Under null hyp.\ $H_0: 
\rho_h = 0$ for $h\geq 1$. So, 

$r_h \sim N(9,1/n)$, for h=1,2,\dots

More generally, for ARMA processes, under $H_0$:

$(r_1, \dots, r_h)' ~ N((\rho_1, \dots,\rho_h)', \frac{1}{n} W)$ 

where

\begin{equation}
\begin{split}
W_{i,j}=&  \sum_{k=1}^{\infty} (\rho_{k+i}+\rho_{k-i} - 2\rho_i \rho_k)\\
~& (\rho_{k+j}+\rho_{k-j}-2\rho_j\rho_k) \quad t,j=1,\dots,h
\end{split}
\end{equation}

Note that this does not test the hypothesis $\rho_h = 0$, where, $h\geq p > 1$.
(what? this doesn't make sense)

\item Test for MA(q): If WN is ruled out, test for MA(q). Recall that for MA(q), $\rho_h = 0$ for $h>q$. 
Under $H_0: \rho_h = 0$, the $\rho_h$ for $h=q+1,q+1,\dots$ are independent. 
So, for an MA(q) process we expect 
for large $n$:

\begin{equation}
r_h \sim N(0,\frac{1+2\sum_{j=1}^q\rho_j^2}{n})
\end{equation}

independently for $h>q$.

So, a CI based test (could be done visually):

\begin{equation}
r_h \in \pm 2\sqrt{\frac{1+2\sum_{j=1}^q\rho_j^2}{n}} \quad \hbox{ for } h>q (h=q+1,q+2,\dots)
\end{equation}

Example: to-do

\item Test for AR(p): Partial ACF.The ACF of an AR(p) model does not cut off sharply but decays geometrically to 0. However, the PACF does does cut off to zero sharply beyond p, just like the MA(q)'s ACF is 0 beyond q.


To construct PACF, we successively build AR(1), AR(2), AR(3), \dots models.

\begin{equation}
\begin{split}
p=1 =& y_t = a_1^{(1)}y_{t-1} + \eps_t\\
p=2 =& y_t = a_1^{(2)}y_{t-1} + a_2^{(2)}y_{t-2} + \eps_t\\
p=3 =& y_t = a_1^{(3)}y_{t-1} + a_2^{(3)}y_{t-2} +
a_3^{(3)}y_{t-2} + \eps_t\\
 & \vdots \\
\end{split}
\end{equation}

We define the PACF at lag h to be $\hat a_h^{(h)}$. It can be thought of as a measure of the linear dependence of $y_t$ on $y_{t-h}$ after dependence on the intervening values $y_{t-1}, y_{t-(h-1)}$ has been taken into account. To simplify notation we can drop the hat on a and also drop the superscript ($a_h$ instead of 
$\hat a_h^{(h)}$).

So the statistical test is that 
$a_h \approx 0$ for $h>p$, i.e., that the PACF cuts off sharply after p.

If $y_t$ is a WN process (i.e., if it is not AR(p)), then 

\begin{equation}
a_h \sim N(0,1/n) \hbox{ independently for } h\geq 1
\end{equation}

Visual check using PACF (just like ACF based test): the lines $\pm 2\sqrt{\frac{1}{n}}$ are the rejection regions. If for a given p+1, $a_{p+1}$ lies inside the CI, then it is an AR(p) process.

Calculating PACF: to-do

\item Principle of parsimony: If AR, MA are not plausible, seek ARMA(p,q), but starting with simplest, i.e., p=q=1.
\end{enumerate}

\subsection{Fitting}

\subsubsection{MLE}

\subsection{Error analysis}

\subsection{Model selection}


\section{Forecasting}

Given data $y_{1:t}$, we want to forecast/predict $\hat y_{t+i}$. $t$ is called the \textbf{forecast origin} and $i$ is called \textbf{lead time}.

\subsection{Criterion for choice of $\hat y_{t+i}$: Minimum mean square error predictor}

Minimize: 

\begin{equation}
E[(\hat y_{t+i} - y_{t+i})^2 \mid y_{1:t}]
\end{equation}

The conditioning takes into account that we have observed $y_{1:t}$ and want to build this information in. 

$\hat y_{t+i}$, and $i\geq 1$ is called ``out of 
sample'' forecast in economics. 
If Z is a random variable, $Var(Z)<\infty$, 

\begin{equation}
f(a) = E[(z-a)^2]
\end{equation}

is minimized. Proof:

\begin{equation}
\begin{split}
f(a) =& E[z^2 - 2az + a^2]\\
=& E[z^2] - 2a E[z] + a^2\\
\end{split}
\end{equation}

Taking derivative:

\begin{equation}
\frac{d(f(a))}{da} = -2 E[z] + 2a 
\end{equation}

Equating this to $0$, we get $a = E[z]$.

The second derivative is positive: 
$\frac{d^2(f(a))}{da^2}=2$. Hence this is a minimum.

So, 

\begin{equation}
\hat y_{t+i} = E[y_{t+i} \mid  y_{1:t}]
\end{equation}

\subsection{Forecasting ARMA(p,q) process}

Model:

\begin{equation}\label{armaequation}
y_t = 
\underbrace{a_1 y_{t-1} + \dots + a_p y_{t-p} + \eps_{t}}_\text{AR(p)} + \underbrace{b_1 \eps_{t-1} + \dots + b_q \eps_{t-q}}_\text{MA(q)}
\end{equation}

i.e., 

\begin{equation}
\phi(B) y_t = h(B) \epsilon_t
\end{equation}

Assume that we know $a,b,\sigma^2$ and that $E[y_t]= 0$.

Invertibility guarantees that (via the $AR(\infty)$ representation): 

\begin{equation}
\epsilon_t = h(B)^{-1} \phi(B) y_t = 
\sum_{j=0}^{\infty} = \delta_i y_{t-j}
\end{equation}

($\delta_j$ are determined by $a$'s and $b$'s.). So if we know $y_t$, we know $\epsilon_t$.

Also, from the $MA(\infty)$ representation:

\begin{equation}
y_t = 
\sum_{i=0}^{\infty} = \zeta_i \epsilon_{t-i}
\end{equation}

So, we can go from $y_t$ to $\epsilon_t$. This becomes relevant below.

\begin{equation}
y_t = E[y_{t+1}\mid y_{1:t}]
\end{equation}

Replacing $t+1$ for $t$ in equation \ref{armaequation}:
$y_{t+1} = 
a_1 y_{(t+1)-1} + \dots + a_p y_{(t+1)-p} + \eps_{(t+1)} + b_1 \eps_{(t+1)-1} + \dots + b_q \eps_{(t+1)-q}$.


\begin{equation}
\begin{split}
y_t =& E[y_{t+1}\mid y_{1:t}] \\
=& 
E[a_1 y_{(t+1)-1} + \dots + a_p y_{(t+1)-p} + \eps_{(t+1)} + b_1 \eps_{(t+1)-1} + \dots + b_q \eps_{(t+1)-q} \mid y_{1:t}]\\
=&
E[a_1 y_{t} + \dots + a_p y_{t+1-p} + \eps_{(t+1)} + b_1 \eps_{t} + \dots + b_q \eps_{t+1-q} \mid y_{1:t}]\\
\end{split}
\end{equation}

Now, if we want $E[y_t \mid y_{1:t}]$, this will simply be the observed value $y_t$ in the vector $y_{1:t}$, since that is all the information we have about it. \textbf{Note that $y_t$ is not a random variable, it is an observed value}.

So, we can write:

\begin{equation}
\begin{split}
y_t =& E[y_{t+1}\mid y_{1:t}] \\
=&
E[a_1 y_{t} + \dots + a_p y_{t+1-p} + \eps_{(t+1)} + b_1 \eps_{t} + \dots + b_q \eps_{t+1-q} \mid y_{1:t}]\\
=& E[a_1 y_{t}\mid y_{1:t}] + \dots + E[a_p y_{t+1-p}\mid y_{1:t}] \\
~& + E[\eps_{(t+1)}\mid y_{1:t}] \\
~& + E[b_1 \eps_{t}\mid y_{1:t}] + \dots + E[b_q \eps_{t+1-q}\mid y_{1:t}]\\
=& a_1 y_{t} + \dots + a_p y_{t+1-p} +
b_1 \eps_{t} + \dots + b_q \eps_{t+1-q}
\end{split}
\end{equation}

The term $E[\eps_{(t+1)}\mid y_{1:t}]=0$, because 

\begin{equation}
\begin{split}
E[\eps_{(t+1)}\mid y_{1:t}] =& E[\eps_{(t+1)} 
\mid \eps_1,\dots, \eps_t]\\
=& E[\eps_{(t+1)} \quad \hbox{ independence }\\
=& 0 \hbox{ by WN }
\end{split}
\end{equation}

This gives us the:

\subsection{One-step predictor}

\begin{equation}
\hat y_{t+1} = 
a_1 y_{t} + \dots + a_p y_{t+1-p} +
b_1 \eps_{t} + \dots + b_q \eps_{t+1-q}
\end{equation}

\subsection{Two- and i-step predictor}

For the $t+2$-th step predictor:

\begin{equation}
\begin{split}
\hat y_{t+2} =&  
a_1 \hat y_{t+1} + a_2 y_{t} \dots + a_p y_{t+2-p} \\
~& +
b_1 \eps_{t} + \dots + b_q \eps_{t+2-q}
\end{split}
\end{equation}

For $t+i$-th step predictor (to-do: 
check this):

\begin{equation}
\begin{split}
\hat y_{t+i} =& 
a_1 \hat y_{t+i-1} + a_2  y_{t} \dots + a_p y_{t+i-p} \\
~& + b_1 \eps_{t} + \dots + b_q \eps_{t+i-q}
\end{split}
\end{equation}

\section{State Space Models}

\subsection{Recall linear regression}

\begin{enumerate}
\item
an $n\times 1$ response vector $y_{1:t}$
\item 
$p$ predictor variables $x_{it}, i=1,\dots,n$. So, we have

$x_{11}, x_{12},\dots,x_{1t}$

$x_{21}, x_{22},\dots,x_{2t}$

etc., so that
$x_t = (x_{1t},\dots,x_{pt})^{T}$. 

For example, $[1 1]^T$ for t=1. For p=2, t=5:

<<>>=
## x^T:
matrix(rep(1,2*5),ncol=2)
@
\end{enumerate}


\begin{equation}
y_t = x_{1t}\beta_1 + \dots + x_{pt} \beta_p + \eps_t = \x_t^T \beta+ \eps_t
\end{equation}

where $\beta=(\beta_1,\dots,\beta_p)^T$, a p-variate vector of regression coefficients.

$\eps_t$ is the error or innovation (white noise).

Estimation is done by minimizing sum of squares:

\begin{equation}
S(\beta) = \sum{t=1}^{n} (y_y - x_t^T \beta)^T
\end{equation}

The vector $\beta$ is time-invariant:  $\beta_n=\beta_{n-1}=\dots=\beta_1=\beta_0$.

\subsection{An almost time-invariant model}

When we have

\begin{equation}
\beta_t \approx \beta_{t-1}
\end{equation}

this can be described by the model

\begin{equation}
\beta_t = \beta_{t-1} + \zeta_t 
\end{equation}

$\zeta_t$ is a random variable, and so $\beta_t$ is also a random variable and is known as a \textbf{state vector}.

This gives us:

\begin{equation}
\begin{split}
y_t =& x_t^T \beta_t + \eps_t \quad \hbox{observation model}\\
\beta_t =& \beta_{t-1} + \zeta_t \quad \hbox{transition model}\\
\end{split}
\end{equation}

$\beta_t$ is modeled as a random walk.

If we set x=1 for all t:
$x_1 = x_2 = \dots = x_t=1$. Then, we get the 
\textbf{local level plus noise model}:

\begin{equation}
y_t = \beta_t + \eps_t \quad 
\beta_t = \beta_{t-1} + \zeta_t
\end{equation}

\textbf{The level of the time series}: $E[y_t\mid \beta_t]= \beta_t$. 

\subsection{The general state space model}

Replaces the random walk of $\beta_t$ with a \textbf{more general Markov chain}. That is:

\begin{equation}
\begin{split}
y_t =& x_t^T \beta_t + \eps_t \hbox{observation model}\\
\beta_t = F\beta_{t-1}+ \zeta_t \hbox{transition model}\\ 
\end{split}
\end{equation}

$\eps_t \sim N(0,\sigma^2) \zeta_t \dim N(0,Z)$

E.g., 

\begin{equation}
Z=
\begin{pmatrix}
\sigma_1^2 & 0 \\
0 & \sigma_2^2
\end{pmatrix}
\end{equation}

Z is the transition covariance matrix.

$\sigma^2$ and $Z$ can be time-varying; in such a case, we would write  $\sigma_t^2$ and $Z_t$.
In finance, $\sigma^2$ represents volatility. 

For now, assume $\sigma^2$ is time-invariant, and $Z_t$ is time-varying. Since $\beta$ are random variables, we have to specify a prior for $\beta_0$:

\begin{equation}
\beta_{0} \sim N(\hat \beta_{0\mid 0}, P_{0\mid 0})
\end{equation}

\subsection{Filtering: Kalman Filter (Theorem 5.1)}

Given:

\begin{equation}
\begin{split}
y_t =& x_t^T \beta_t + \eps_t \quad \hbox{(observational model)}\\
\beta_1 =& F\beta_{t-1} + \zeta_t \quad \hbox{(transition model)}\\
\beta_{0} =& N(\hat \beta_{0\mid 0}, P_{0\mid 0})\\
\end{split}
\end{equation}

For each $t=1,\dots,n$, the following applies:

\begin{enumerate}
\item 
The forecast distribution of $\beta_t$ at $t-1$ is 

\begin{equation}
\beta_t \mid y_{1:t-1}\sim N(\hat \beta_{t\mid t-1}, P_{t\mid t-1})
\end{equation}

where 
\begin{enumerate}
\item
$\beta_{t\mid t-1} = F\hat \beta_{t-1\mid t-1}$
\item
$P_{t\mid t-1} = FP_{t-1\mid t-1} F^T + Z_t$
\end{enumerate}

(The transition matrix F gives the next value.)

\item The posterior distribution of $\beta_t$ at time $t$ is 

\begin{equation}
\beta_t \mid y_{1:t}  \sim N(\hat \beta_{t\mid t}, P_{t\mid t})
\end{equation}

\noindent
where 

\begin{enumerate}
\item
$\hat \beta_{t\mid t} = \hat \beta_{t\mid t-1} + k_t \eps_t$
\item 
$\hat y_{t\mid t-1} = x_t^T \hat \beta_{t\mid t-1}$
\item 
$e_t = y_t - \hat y_{t\mid t-1}$
\item Forecast variance:
$q_{t\mid t-1} = x_t^T P_{t\mid t-1} x_t + \sigma^2$
\item Kalman gain:
$k_t = \frac{P_{t\mid t-1} x_t}{q_{t\mid t-1}}$
\item 
$P_{t\mid t} = P_{t\mid t-1} - q_{t\mid t-1} k_t k_t^T$

Note that 
$P_{t\mid t-1} = U_p D_p^2 U_p^T$
\end{enumerate}
\end{enumerate}

Some notes:

\begin{enumerate}
\item 
$\hat \beta_{t\mid t-1}$ is the \textbf{mean} at time $t$ given data up to time $t-1$: $E[\beta_t \mid y_{1:t-1}]$.
\item
When $y_t$ is observed, the data set goes from

$1:y_{t-1}$ to $1:y_t$ and then the $\hat \beta_{t\mid t}$ is the mean $E[\beta_t \mid t_{1:t}]$.
\item
\begin{enumerate}
\item
So, $t\mid t-1$ means: \textbf{forecast} at time t given information $y_{1:t}$.
\item
$t\mid t$ means \textbf{filtered estimate} at time $t$ given information $y_{1:t}$.
\end{enumerate}
\item 
$\hat y_{t\mid t-1}$ is the one-step ahead forecast of $y_t$ given information $y_{1:t-1}$.
\item
$e_t$ is the one-step ahead prediction error.
\item 
The conditional distribution of $\beta_t\mid y_{1:t}$ is the posterior distribution of $\beta_t$ at time $t$. 

\begin{equation}
p(\beta_t \mid y_{1:t}) \propto \explain{p(y_t \mid \beta_t)}{\hbox{Lik.}} 
\explain{p(\beta_t\mid y_{1:t-1})}{\hbox{Prior}}
\end{equation}

\begin{enumerate}
\item
The likelihood is from a single observation
\item
The prior is at time $t$.
\end{enumerate}

\end{enumerate}

So, the Kalman filter gives:

\begin{table}[htdp]
%\caption{default}
\begin{center}
\begin{tabular}{ccccccc}
$t$ & 0 & 1 & 1 & 2 & 3 & 4\\
$y_t$ &  & $y_1$ & $y_2$ & $y_3$ & $y_4$\\
$\beta_{t\mid t}$ & $\hat \beta_{1\mid 0}$ & $\hat \beta_{2\mid 1}$ & $\hat \beta_{2\mid 2}$ & &\\
$P_{t\mid t}$ & $P_{1\mid 0}$ & $P_{2\mid 1}$ & $P_{2\mid 2}$ & & \\
\end{tabular}
\end{center}
%\label{default}
\end{table}%

The great thing about the Kalman filter is that to compute $\hat \beta_{2\mid 2}$ we only need $\hat \beta_{2\mid 1}$, and to compute $P_{2\mid 2}$ only need $P_{2\mid 1}$. 

%\begin{equation}
%F=
%\begin{pmatrix}
%1 & 1\\
%0 & 1\\
%\end{pmatrix}
%\quad 
%\beta_{t-1}= 
%\begin{pmatrix}
%\beta_0_{t-1}\\
%\beta_1_{t-1}\\
%\end{pmatrix}
%\end{equation}

\subsection{Forecasting}

Given data: $y_{1:t} = \{ y_1,\dots, y_t\}$, need to derive the distribution of

\begin{enumerate}
\item $\beta_{t+i}$, the \textbf{i-step ahead forecast state}
\item $y_{t+i}$, the \textbf{i-step ahead observation distribution}
\end{enumerate}

The variable $i$ is called \textbf{lead time}. and the maximum value $i$ takes is called forecast horizon.

\subsection{Fully worked examples using library \texttt{dlm}}

The data-set is Central England temperatures.

<<echo=FALSE>>=
dir<-"/Users/shravanvasishth/Dropbox/MScStatistics/2014-2015/MAS6011/Semester2/Data/"
@

<<>>=
library(dlm)

## Central England temperatures:
temp<-read.table(paste(dir,"temp.txt",
                        sep=""))
temp<-ts(temp[,2],start=1659,
         frequency=1)
x<-matrix(1)
## transition matrix:
F<-matrix(1)
## epsilon:
sigma2<-1
## zeta variance matrix:
Z<-10
## Prior beta ~ N(beta0,P0):
beta0<-9
P0<-1000
## model:
mod<-dlm(temp,
         FF=x, ## predictor 
         GG=F, ## transition matrix
         V=sigma2, ## epsilon var
         W=Z,      ## zeta var
         m0=beta0, ## prior mean beta
         C0=P0)    ## prior var  beta
fit<-dlmFilter(temp,mod)   

## Forecasting:
modForecast<-dlmForecast(mod=mod,nAhead=3)

## invariant forecast mean is 
## a characteristic of the local 
## level model:
modForecast$a[[1]]
modForecast$a[[2]]
modForecast$a[[3]]

modForecast$Q[[1]]
modForecast$Q[[2]]
modForecast$Q[[3]]

lower<-rep(NA,3)
upper<-rep(NA,3)
## intervals:
for(i in 1:3){
lower[i]<-modForecast$a[[i]]
           -2*sqrt(modForecast$Q[[i]])
upper[i]<-modForecast$a[[i]]
           +2*sqrt(modForecast$Q[[i]])
}
## uncertainty increases with i:
(forecst<-data.frame(i=1:3,lower=lower,
                     upper=upper))
@



\end{multicols}

\end{document}

